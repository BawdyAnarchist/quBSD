#!/bin/sh

preinstall_variables() {
	# Define files 
	qlog="/var/log/qubsd_install_log"
	BSDiso="FreeBSD-13.0-RELEASE-amd64-bootonly.iso"
	date=$(date +%b%d)
	tyme=$(date +%H%M)

	zpools=$(zpool list -H -o name)
	zusrlist="0net-template 0gui-template net-tap net-vpn net-firewall dispjail"
	
	# Define mountpoints 
	m_jails="/quBSD/jails"
	m_zusr="/quBSD/zusr"

	# Define datasets, if they exist
	if [ -e /usr/local/etc/jail.conf.d/quBSD.conf ] ; then
		zusr_zfs=$(sed -En "s/^zusr_dataset[[:blank:]]+//p" /usr/local/etc/jail.conf.d/quBSD.conf)
		jails_zfs=$(sed -En "s/^jails_dataset[[:blank:]]+//p" /usr/local/etc/jail.conf.d/quBSD.conf)
		zroot=$(sed -nE "s:quBSD_root[[:blank:]]+::p" /usr/local/etc/jail.conf.d/quBSD.conf)
	fi
}

preinstall_confirmation() {
	clear 

	printf "%b" "\nWELCOME TO THE QUBSD INSTALLER\n" \
			"\nrootjail directories are stored separately from persistent user data." \
			"\nTypically, rootjails will be stored on zroot; and it's recommended to" \
			"\nselect a separate pool for user data, but not strictly required.\n"

	if [ -z "$zpools" ] ; then
		printf "%b" "\nInstaller did not detect any zpools. ZFS is required for" \
				"\nquBSD, please create at least one zpool, and try again."
		exit 1

	elif [ `echo "$zpools" | wc -l` = "1" ] ; then
		printf "%b" "\n$zpools is the only pool. The following datasets will be created:\n" \
				"\n${zpools}/quBSD/jails  will store rootjail data; and" \
				"\n${zpools}/quBSD/zusr  will store user data (referred to as \"zusr\")"
		
		sys_root="${zpools}"
		zroot="${zpools}/quBSD"
		jails_zfs="${zpools}/quBSD/jails"	
		zusr_zfs="${zpools}/quBSD/zusr"	

	else
		printf "%b" "\nThe following zpools were detected:\n"
		zpool list

		# rootjail zpool selection
		printf "%b" "\nSelect the pool to use for rootjail data (recommend zroot)" \
				"\n\tEnter zpool name:  "
		while : ; do
			read jails_pool 
			if `echo "$zpools" | grep -qs "^$jails_pool\$"` ; then
				# Remove blanks, define jails_zfs
				jails_pool2=$(echo $jails_pool | sed -n "s/[[:blank:]]*//p")
				sys_root="${jails_pool2}"
				zroot="{$jails_pool2}/quBSD"
				jails_zfs="$jails_pool2/quBSD/jails"
				break
			fi
			printf "%b" "\nInvalid response, please try again. Choose pool:  "
		done

		# zusr zpool selection
		printf "%b" "\nquBSD refers to the dataset containing user data as: \"zusr\"" \
				"\nRecommend selecting a different pool for zusr (but not stricly required)" \
				"\n\tEnter zpool name:  "

		while : ; do
			read zusr_pool 
			if `echo "$zpools" | grep -qs "^$zusr_pool\$"` ; then
				# Remove blanks, define zusr_zfs
				zusr_pool2=$(echo $zusr_pool | sed -n "s/[[:blank:]]*//p")
				zusr_zfs="$zusr_pool2/quBSD/zusr"
				break
			fi
			printf "%b" "\nInvalid response, please try again. Choose pool:  "
		done

		# Summarize new datasets and mountpoints
		printf "%b" "\nThe following datasets will be created:" \
				"\n\t${jails_zfs}  will store rootjail data; mounted at $m_jails" \
				"\n\t${zusr_zfs}   will store user data; mounted at $m_zusr" 
	fi
	
	printf "%b" "\n\nUser can change mountpoints after installer is complete. For example:" \
			"\n\tzfs set mountpoint=/jails $jails_zfs" \
			"\n\nPress {ENTER} to continue with pre-install checks."
			read cont
	clear

	zfs list $jails_zfs >> /dev/null 2>&1		
	if [ "$?" = "0" ] ; then
		destroy_jails_zfs="true"
		printf "%b" "\nWARNING: It appears that there's already a dataset at: $jails_zfs" \
				"\nThe installer will destroy this dataset and replace it.\n\n"
	fi

	zfs list $zusr_zfs >> /dev/null 2>&1		
	if [ "$?" = "0" ] ; then
		destroy_zusr_zfs="true"
		printf "%b" "\nWARNING: It appears that there's already a dataset at: $zusr_zfs" \
				"\nThe installer will destroy this dataset and replace it.\n\n"
	fi

	ping -o -t 5 ftp4.freebsd.org 
	if [ "$?" != "0" ] ; then
		printf "%b" "\nERROR! No ping response from ftp4.freebsd.org . Connection is" \
		"\nrequired to fetch quBSD files, and a FreeBSD install iso. Exiting.\n"
		exit 1
	else 
		printf "%b" "\nPing check successful, internet connection present.\n" 
	fi

	printf "%b" "\nAny .conf files to be modified by installer will first be copied to:" \
			"\n/root/old_configs/ and snapshots taken (if root system is zfs based)." \
			"\nRegardless, MAKE SURE TO BACKUP YOUR DATA BEFORE PROCEEDING." \
			"\n\n\tPress {ENTER} to continue to final message before install"
			read resp
	clear

	printf "%b" "\nContinuing to installation. A couple notes ...\n" \
	"\n- This is an interactive script. User input is required at VM and jails install screens." \
	"\n- Remember there are multiple ttys; if you need a console while script is running." \
	"\n- At a few points, the installer will slow. Wait a few minutes before sending SIGINT." \
	"\n\tIf interrupted, there is a log file at: /var/log/qubsd_install_log" \
	"\n\nFINAL CONFIRMATION FOR INSTALLER TO PROCEED (y/n):  "
	
	read resp
	if [ "$resp" != "y" -a "$resp" != "Y" ] ; then
		printf "%b" "\nDid not receive \"y\" response. Exiting\n\n"  | tee -a $qlog  
		exit 1
	fi
}

datasets_prepare() {
	echo "DATASETS_PREPARE_STARTING" >> $qlog
	clear 
	
	# Take snapshots of the root system if able.
	if [ -n "$zroot" ] ; then
		printf "%b" "\n\nSnapshots have been take of the following:\n" | tee -a $qlog
		zfs snapshot "${sys_root}/ROOT/default@quBSD_${date}_${tyme}"  >> $qlog 2>&1
		zfs snapshot "${sys_root}/usr@quBSD_${date}_${tyme}"  		>> $qlog 2>&1
		zfs snapshot "${sys_root}/home@quBSD_${date}_${tyme}"   	>> $qlog 2>&1
		zfs list -t snapshot | grep '@quBSD' | tee -a $qlog
	fi

	# Fetch a copy of the ISO for VM install later on
	if ! [ -e "/usr/local/share/${BSDiso}" ] ; then
		fetch -aq -o /usr/local/share/ \
				http://ftp4.freebsd.org/pub/FreeBSD/releases/ISO-IMAGES/13.0/${BSDiso} &
		fetchpid=$(echo "$!" | tee -a $qlog)
		printf "%b" "\nDownloading FreeBSD bootonly iso for bhyve VM install. Saving to:" \
				"\n/usr/local/share/${BSDiso}"
	fi

	# Destroy existing datasets; and create new ones
	[ "$destroy_jails_zfs" ] && zfs destroy -rRf $jails_zfs
	[ "$destroy_zusr_zfs" ] && zfs destroy -rRf $zusr_zfs
	zfs create -p -o mountpoint="$m_jails" $jails_zfs
	zfs create -p -o mountpoint="$m_zusr" $zusr_zfs

	# Fetch the repo and unzip
	fetch -o ${m_jails} https://github.com/BawdyAnarchist/quBSD/archive/refs/heads/main.zip 
	unzip -qd ${m_jails} ${m_jails}/main.zip	
	mv ${m_jails}/quBSD-main ${m_jails}/quBSD
	rm ${m_jails}/main.zip

	# Backup any config files that will be modified
	[ -e /root/old_configs ] || mkdir /root/old_configs/  
	all_files=$(find "${m_jails}/quBSD/zroot" -type f | sed "s#^${m_jails}/quBSD/zroot##")

	for f in $all_files ; do
		[ -e $f ] && cp -a $f /root/old_configs/
	done

	printf "%b" "\n\nThe following files were backed up to /root/old_configs\n" | tee -a $qlog
	ls -C /root/old_configs/

	printf "%b" "\n\tPress {ENTER} to continue\n" 
	read cont 

	echo "DATASETS_PREPARE_FINISHED" >> $qlog
}

qubsd_files_copy() {
	echo "QUBSD_FILES_COPY_STARTING" >> $qlog
	clear

	# Create zusr datasets, and copy quBSD files
	for z in $zusrlist ; do 
		zfs create ${zusr_zfs}/$z
		cp -a ${m_jails}/quBSD/zusr/$z/ ${m_zusr}/$z/
		sed -i '' -e "s:m_zusr:${m_zusr}:g" ${m_zusr}/${z}/rw/etc/fstab
		sed -i '' -e "s:m_jails:${m_jails}:g" ${m_zusr}/${z}/rw/etc/fstab
	done	

	# Make directories that might not exist
	[ -e /usr/local/etc/jail.conf.d ] || mkdir -p /usr/local/etc/jail.conf.d    
	[ -e /usr/local/etc/rc.d ] || mkdir -p /usr/local/etc/rc.d   
	[ -e /root/.config/i3 ] || mkdir -p /root/.config/i3   
	[ -e /usr/local/etc/X11/xinit ] || mkdir -p /usr/local/etc/X11/xinit   

	# Copy files 
	cp -a ${m_jails}/quBSD/zroot/etc/pf.conf /etc/pf.conf
	cp -a ${m_jails}/quBSD/zroot/etc/pf_pass.conf /etc/pf_pass.conf
	cp -a ${m_jails}/quBSD/zroot/etc/jail.conf /etc/jail.conf   
	cp -a ${m_jails}/quBSD/zroot/usr/local/share/quBSD /usr/local/share
	cp -a ${m_jails}/quBSD/zroot/usr/local/etc/jail.conf.d/* /usr/local/etc/jail.conf.d
	cp -a ${m_jails}/quBSD/zroot/usr/local/etc/rc.d/* /usr/local/etc/rc.d/   
	cp -a ${m_jails}/quBSD/zroot/usr/local/bin/* /usr/local/bin/   
	# i3 files
	cp -a ${m_jails}/quBSD/zroot/root/.config/i3/i3gen.conf /root/.config/i3/
	cp -a ${m_jails}/quBSD/zroot/root/.config/i3/i3gen.sh /root/.config/i3/
	if ! [ -e /root/.config/i3/config ] ; then 
		cp -a ${m_jails}/quBSD/zroot/root/.config/i3/config /root/.config/i3/
	else
		cp -a ${m_jails}/quBSD/zroot/root/.config/i3/config_qubsd /root/.config/i3/
		# If the config already exists, replace $mod+(Shift)+Return with quBSD convention 
		sed -i '' -e '/bindsym $mod+Return/ d' /root/.config/i3/config
		sed -i '' -e "/start a terminal/ r ${m_jails}/quBSD/zroot/root/.config/i3/modlines" \
														/root/.config/i3/config
		sed -i '' -e '/start a terminal/ d' /root/.config/i3/config
	fi

	# APPEND/MODIFY CONFIG FILES THAT SHOULD BE PRESERVED

	# Modify quBSD.conf with user specified datasets
	sed -i '' -e "s:^jails_dataset.*:jails_dataset         ${jails_zfs}:" \
										/usr/local/etc/jail.conf.d/quBSD.conf

	sed -i '' -e "s:^zusr_dataset.*:zusr_dataset           ${zusr_zfs}:" \
										/usr/local/etc/jail.conf.d/quBSD.conf

	sed -i '' -e "s:^jails_dataset.*:jails_dataset         ${jails_zfs}:" \
										/usr/local/etc/jail.conf.d/quBSD.conf

	if ! `cat /usr/local/etc/X11/xinit/xinitrc | grep -qs 'xhost + local:'` ; then
		echo "xhost + local:" | tee -a $qlog   >> /usr/local/etc/X11/xinit/xinitrc
	fi

	# rc.conf
	printf "%b" "\n# quBSD Modifications\n" >> /etc/rc.conf
	cat ${m_jails}/quBSD/zroot/etc/rc.conf | xargs sysrc  | tee -a $qlog

	# If devfs.rules already exists, then find available rule numbers 
	[ -e /etc/devfs.rules ] || cp /etc/defaults/devfs.rules /etc/devfs.rules

	# Attempts to search for the last rulenumber, and starts searching from there
	rulenum1=$(sed -n "s/^\[devfsrules.*=//p ; s/\]//p" /etc/devfs.rules | tail -1)
	rulenum2=$(( rulenum1 + 1 ))
		while : ; do
			rulenum1=$(( rulenum1 + 1 ))
			rulenum2=$(( rulenum2 + 1 ))
			! `egrep -qs "^\[devfsrules.*=${rulenum1}" /etc/devfs.rules` && \
			! `egrep -qs "^\[devfsrules.*=${rulenum2}" /etc/devfs.rules` && break
		done

	# Modify devfs.rules
	cat ${m_jails}/quBSD/zroot/etc/devfs.rules >> /etc/devfs.rules 
	sed -i '' -e "s/NETRULENUM1/$rulenum1/" /etc/devfs.rules   >> $qlog 2>&1
	sed -i '' -e "s/NETRULENUM1/$rulenum1/g" /etc/jail.conf   >> $qlog 2>&1
	sed -i '' -e "s/GUIRULENUM2/$rulenum2/" /etc/devfs.rules   >> $qlog 2>&1
	sed -i '' -e "s/GUIRULENUM2/$rulenum2/g" /etc/jail.conf   >> $qlog 2>&1

	# Modify jail.conf with m_zusr and m_jails
	sed -i '' -e "s:m_jails:${m_jails}:g" /etc/jail.conf   >> $qlog 2>&1
	sed -i '' -e "s:m_zusr:${m_zusr}:g" /etc/jail.conf   >> $qlog 2>&1

	# 0gui-template needs user-level permissions applied
	chown -R 1001:1001 ${m_zusr}/0gui-template/home/0gui-template
	chflags -R noschg ${m_zusr}/0gui-template/home/0gui-template

	printf "%b" "\nFiles copied from quBSD repo to their respective directories," \
			"\nand/or modifications have been made." \
			"\n\nXorg Notes: If you install Xorg after this, it might overwrite xinitrc." \
			"\nGUI jails, require this file to contain the line:  xhost + local: " \
			"\n\ni3wm Notes: A couple lines were added to your config, commented with quBSD" \
			"\nChech the file: /root/.config/i3/config_qubsd for potential merge with your own." \
			"\n\n\tPRESS {ENTER} TO CONTINUE\n" ; read cont 
	
	echo "QUBSD_FILES_COPY_FINISHED" >> $qlog
}

pcidevice_variables() {
	# IP Addresses
	nicIP1=$(sed -n "s/^nicvm[[:blank:]]*IP0[[:blank:]]*//p" /usr/local/etc/jail.conf.d/jailmap.conf)
	nicIP1="${nicIP1%/*}"
	nicIP2="${nicIP1%.*}.2/24"
	usbIPtemp="${nicIP1%.*}.3/24"
	
	# Network Interfaces
	intf_list=$(ifconfig -l | sed "s/lo0//")
	interface=$(ifconfig | egrep -B3 "inet.*broadcast" | egrep -o "^[[:alnum:]]*")

	# PCI Devices
	usb_pcis=$(pciconf -lv | egrep -B4 "subclass[[:blank:]]*=[[:blank:]]*USB")
	nvidia=$(pciconf -lv | grep -B3 "= display" | grep -o NVIDIA)
}

network_card_select() {
	echo "NETWORK_CARD_SELECT_STARTING"  >> $qlog
	clear

	pcidevice_variables

	printf "%b" "\nWe need to find your network card to put inside of the nicvm\n" \
		     "It should be one of these interfaces:   " "$intf_list" "\n" \
			"\nAnd it appears that this interface(s) is/are connected\n" \
			"right now (likely from DHCP connection at install):  $interface"
	sleep 3 
	printf "%b" "\n\nHere is some additional data on the connected interface(s)\n\n"

	for i in $interface ; do
		ifconfig $i  | tee -a $qlog
		echo ""
		pciconf -lv | egrep -A3 "^$i"  | tee -a $qlog
		echo ""
	done

	printf "%b" "Does this look correct (YES), or do you want to see more possibilities (NO)?\n" \
		    "                                   Yes ready to confirm / No more info (y/n):  " 
	read resp

	while : ; do
		if [ "$resp" != "y" ] ; then
			clear
			printf "%b" "\nHere is the list of *all* interfaces currently on host\n\n"  
			ifconfig  
			printf "%b" "\nAnd here is the list of your PCI devices tagged with \"= network\"\n\n" 
			pciconf -lv | grep -B3 "= network" 
		fi

		printf "%b" "\n\nPlease enter the network interface for PCI passthrough:  " | tee -a $qlog
		read interface
		printf "%b" "\n"

		nicnum=$(pciconf -l $interface | sed "s#${interface}\@pci.:##" | \
			sed "s#.[[:blank:]]*class.*##" | sed "s#:#/#g" | tee -a $qlog)

		if [ -z "$nicnum" -o -z "$interface" ] ; then
			 printf "%b" "\nTHE INTERFACE YOU SELECTED HAS NOT BEEN FOUND IN \`pciconf -lv\`" \
			 	"\n\tThe interface you entered was:  $interface" \
			"\n\tNext screen will show a list of all possible interfaces" \
			"\n\tPlease select a valid interface for PCI passthrough to the nicvm" \
			"\n\n\tPRESS {ENTER} TO CONTINUE"  | tee -a $qlog
			resp="n"
			read badchoice
		else
			break
		fi
	done
	echo "NETWORK_CARD_SELECT_FINISHED"  >> $qlog
}

usb_slots_select() {
	echo "USB_SLOTS_SELECT_STARTING"  >> $qlog
	clear

	printf "%b" "\nYou have selected $interface which will be saved to config files as PCI bus $nicnum \n\n" | tee -a $qlog
	printf "%b" "\nNow we need to select USB PCI slots to send the usbvm. Unfortunately there's no easy way to" \
		"\ntell which entry corresponds to which physical port. Your best bet is to select from this" \
		"\nlist, and after reboot, sequentially plug a flash drive to each USB slot until you find" \
		"\nwhich ones don't have a dmesg response (indicating you've found the passthrough slots)." \
		"\n\nHere are the PCI buses tagged as host controller interfaces. It's probable that the higher" \
		"\nnumbered buses correspond to physical USB slots on the front/top facing part of your desktop" \
		"\n\n" "$usb_pcis" "\n\n"

	printf "%b" "Time to roll the dice. Select up to two devices. One device per line." \
		"\nOnly need to enter the device name, not the \"@pcia:b:c:d\" part" \
		"\n{ENTER} blank to skip"

	while : ; do
		printf "%b" "\n\nEnter selection for first USB:  " ; read usb1
		if [ -z $usb1 ] ; then
			skip=$(echo "false" | tee -a $qlog)
			break
		fi
	
		pciconf -l $usb1 >> /dev/null 2>&1
		if [ "$?" = "0" ] ; then
			usbnum1=$(pciconf -l $usb1 | sed -E "s/.+\@pci[[:digit:]]://" | sed -E "s/:[[:blank:]]+.*//" | sed "s#:#/#g")
			break
		else	
			printf "%b" "\nError: Not a valid entry. Please try again" 
		fi
	done

	while $skip ; do
		printf "%b" "\n\nEnter selection for second USB:  " ; read usb2
		if [ -z $usb2 ] ; then
			break
		fi

		pciconf -l $usb1 >> /dev/null 2>&1
		if [ "$?" = "0" ] ; then
			usbnum2=$(pciconf -l $usb2 | sed -E "s/.+\@pci[[:digit:]]://" | sed -E "s/:[[:blank:]]+.*//" | sed "s#:#/#g")
			break
		else
			printf "%b" "\nError: Not a valid entry. Please try again (or press ENTER to skip)" 
		fi
	done
	
	echo "USB_SLOTS_SELECT_FINISHED"  >> $qlog
}

pptdevs_confirm() {
	echo "PPTDEVS_CONFIRM_STARTING"  >> $qlog
	clear
	printf "%b" "\n\nPlease review the selections you have made.\nNetworking Card:   $interface" \
		"\n\t  USB 1:   $usb1" "\n\t  USB 2:   $usb2" \
		"\n\nThe configuration files record these interfaces with \njust the numbered buses " \
		"in this format:  " "$nicnum " " $usbnum1 " " $usbnum2" \
		"\n\nBelow are the details of these devices for your review and final confirmation.\n\n"  | tee -a $qlog
	[ -n "$interface" ] && pciconf -lv | egrep -A4 "$interface"  | tee -a $qlog
	[ -n "$usb1" ] && pciconf -lv | egrep -A4 "$usb1"  | tee -a $qlog
	[ -n "$usb2" ] && pciconf -lv | egrep -A4 "$usb2"  | tee -a $qlog

	printf "%b" "\nIf this is correct, then confirm to proceed with config file edits." \
	"\nIf this is not correct, you will be returned to select NIC and USB PCI slots again." \
	"\n\n                                                CONTINUE WITH INSTALLATION (y/n):  " 
	read finalPPT 

	echo "PPTDEVS_CONFIRM_FINISHED"  >> $qlog
}

pptdevs_selection_loop() {
	echo "PPTDEVS_SELECTION_LOOP_STARTING"  >> $qlog
	while : ; do
		network_card_select	
		usb_slots_select	
		pptdevs_confirm	
			if [ "$finalPPT" != "y" -a "$finalPPT" != "Y" ] ; then
				printf "%b" "\n\nDid not receive a \"yes\" response. " \
					"Returning to re-select PCI slots"  | tee -a $qlog
				# Must reset skip variable for the usb2 while loop
				skip=$(echo "true" | tee -a $qlog)
				sleep 1.5 
			else
				break
			fi
	done
	echo "PPTDEVS_SELECTION_LOOP_FINISHED"  >> $qlog
}

qubsd_files_modify() {
	echo "QUBSD_FILES_MODIFY_STARTING"  >> $qlog

	# Modify loader.conf for boot mute and rctl 

	newppts=$(echo $nicnum $usbnum1 $usbnum2 | tee -a $qlog)
	if [ -n "$newppts" ] ; then
		sysrc -f /boot/loader.conf vmm_load="YES" | tee -a $qlog
		sysrc -f /boot/loader.conf pptdevs+="$newppts" | tee -a $qlog
	fi

	if ! `grep -qs 'boot_mute="YES"' /boot/loader.conf` ; then
		sed -i '' -E "/boot_mute/ d" /boot/loader.conf
		echo '' >> /boot/loader.conf
		echo '# quBSD: boot_mute prevents VM messages from clogging host ttyv0' >> /boot/loader.conf
		echo 'boot_mute="YES"' >> /boot/loader.conf
	fi

	if ! `grep -qs 'kern.racct.enable="1"' /boot/loader.conf` ; then
		sed -i '' -E "/kern.racct.enable/ d" /boot/loader.conf
		echo '' >> /boot/loader.conf
		echo '# quBSD: rctl is required for jails security settings' >> /boot/loader.conf
		echo 'kern.racct.enable="1"' >> /boot/loader.conf
	fi

	# AMD CPU needs special kernel tuning 
	if `dmesg | grep -Eqs "^CPU.*AMD"` ; then
		if ! `grep -qs 'hw.vmm.amdvi.enable="1"' /boot/loader.conf` ; then
			sed -i '' -E "/hw.vmm.amdvi.enable/ d" /boot/loader.conf
			echo '' >> /boot/loader.conf
			echo '# quBSD: Detected AMD CPU, which needs amdvi enabled for VMs' >> /boot/loader.conf 
			echo 'hw.vmm.amdvi.enable="1"' >> /boot/loader.conf 
		fi

		if ! `grep -qs 'kern.sysctl kern.sched.steal_thresh="0"' sysctl.conf` ; then
			sed -i '' -E "/kern.sysctl kern.sched.steal_thresh/ d" /etc/sysctl.conf
			echo '' >> /etc/sysctl.conf
			echo '# quBSD: Detected AMD CPU - Video playback improved with thresh=0' >> /etc/sysctl.conf
			echo 'kern.sysctl kern.sched.steal_thresh="0"' >> /etc/sysctl.conf
		fi
	fi

	printf "%b" "\n\n/boot/loader.conf has been modified with the passthrough devices:  " \
			"\n\tpptdevs=\"$nicnum $usbnum1 $usbnum2\""

	printf "%b" "\nnicnum=$nicnum\n" >> $qlog

	# Modify nicvm data 
	echo "ppt_nic     $nicnum"  >>  /usr/local/etc/jail.conf.d/quBSD.conf
	sed -i '' -e "s#ext_if =.*#ext_if = \"$interface\"#" \
										${m_jails}/quBSD/zroot/nicvm/pf.conf
	if [ "$usbnum1" ] ; then
		echo "ppt_usb1    $usbnum1" >>  /usr/local/etc/jail.conf.d/quBSD.conf
	fi
	if [ "$usbnum2" ] ; then
		echo "ppt_usb2    $usbnum2" >>  /usr/local/etc/jail.conf.d/quBSD.conf
	fi
	cat /usr/local/etc/jail.conf.d/quBSD.conf | column -t > /usr/local/etc/jail.conf.d/quBSD2.conf 
	mv /usr/local/etc/jail.conf.d/quBSD2.conf /usr/local/etc/jail.conf.d/quBSD.conf 

	# Modify devfs.rules based on graphics card
	if [ "$nvidia" ] ; then
		sed -i '' -e "s/add path.*dri.*/#&/g" /etc/devfs.rules  
		sed -i '' -e "s/add path.*drm.*/#&/g" /etc/devfs.rules 
		sed -i '' -e "s/add path.*pci.*/#&/g" /etc/devfs.rules
		nvidia=$(echo "nvidia-driver" | tee -a $qlog)
	else
		sed -i '' -e "s/add path.*nvidia.*/#&/" /etc/devfs.rules
		drmkmod=$(echo "drm-kmod" | tee -q $qlog)
	fi
	echo "QUBSD_FILES_MODIFY_FINISHED"  >> $qlog
}

rootjails_installation() {
	echo "ROOTJAILS_INSTALLAITON_STARTING"  >> $qlog

	printf "%b" "\nWe're ready now to install / configure jails, starting with the first rootjail:  0base" \
		"\n\nPlease complete the \`bsdinstall\` screen - important notes for what to select:  " \
		"\n\n\tDESELECT EVERYTHING EXECPT FOR:  SSHD" \
		"\n\tAdd a password (better if it's different than host root password)" \
		"\n\tDO NOT add users" \
		"\n\n\t\tpress {enter} to continue to bsd installer ...\n"
	read cont 
	
	zfs create ${jails_zfs}/0base
	bsdinstall jail ${m_jails}/0base  
	clear

	printf "%b" "\nJail install successful!  Now we need to apply updates. \n\nRemember, when you arrive at " \
		"the list of pkgs to be applied, keep pressing \"q\" until the end of the list." \
		"\n\n\t\tpress {enter} to continue to the update screen ..." | tee -a $qlog
	read cont

	ASSUME_ALWAYS_YES="yes"
	export ASSUME_ALWAYS_YES

	freebsd-update -b ${m_jails}/0base fetch install
	chroot ${m_jails}/0base/ /usr/sbin/pkg update

	mkdir ${m_jails}/0base/rw  
	mkdir ${m_jails}/0base/home
	cat /etc/fstab | head -1 > ${m_jails}/0base/etc/fstab
	head -8 ${m_zusr}/0gui-template/rw/etc/rc.conf > ${m_jails}/0base/etc/rc.conf

	basesnap="${jails_zfs}/0base@${date}_${tyme}"
	zfs snapshot $basesnap  
	zfs send $basesnap | zfs recv ${jails_zfs}/0net   >> $qlog 2>&1
	zfs send $basesnap | zfs recv ${jails_zfs}/0gui   >> $qlog 2>&1

	clear

	printf "%b" "\nJail updates and pkg updates applied successfully!" \
		"\n\n0base has been duplicated to two new zfs datasets: 0net and 0gui\n" \
		"Which are rootjails for network and gui jails. Current state of ${jails_zfs}: \n\n" 

	zfs list -rt all ${jails_zfs} 

	printf "%b" "\n\nPRESS {ENTER} TO CONTINUE TO ROOTJAIL PACKAGES SELECTION AND INSTALLATION"
	read cont
	echo "ROOTJAIL_INSTALLATION_FINISHED"  >> $qlog
}

rootjails_packages() {
	echo "ROOTJAILS_PACKAGES_STARTING"  >> $qlog
	clear

	xtrapkgs="qt5 vim dbus keepassxc falkon libreoffice firefox xpdf spectacle"

	printf "%b" "\n0net and 0gui rootjails need purpose-specific packages installed:  \n" \
		"\nIMPORTANT: It appears that you need the driver:  $nvidia $drmkmod for your graphics card." | tee -a $qlog

	if [ "$nvidia" ] ; then
		printf "%b" "\n\nIf this is correct, quBSD installer will add $nvidia to 0gui ; and devfs.rules" \
		"\nhas already been updated to expose the card to gui jails. HOWEVER, you must ensure the host" \
		"\nhas nvidia-driver and nvidia-settings installed, and the kernel module nvidia-modeset.ko" \
		"\n\n\t  YES to include $nvidia with the other 0gui pkgs / NO to disinclude it (y/n):  "
		read graphics

		if [ "$graphics" != "y" -a "$graphics" != "Y" ] ; then
			printf "%b" "\nInstaller will skip install of nvidia, and only install Xorg. You must" \
			"\nto manually configure your jail's packages, and /etc/devfs.rules."  | tee -a $qlog
			jailpkgs="Xorg"	
		else
			printf "%b" "\nInstaller will install nvidia along with Xorg"   | tee -a $qlog
			jailpkgs="Xorg $nvidia"
		fi

   	     elif [ "$drmkmod" ] ; then
			printf "%b" "\n\nIf this is correct, quBSD installer will add $drmkmod to 0gui ; and devfs.rules" \
			"\nhass already been updated to expose the card to gui jails. HOWEVER:" \
			"\n\t1. You must ensure the host has all required drivers and kernel modules; and" \
			"\n\t2. You likely need additional pkgs installed to 0gui for optimal graphcis performance." \
			"\n\n\t\tYES to include $drmkmod with the other 0gui pkgs / NO to disinclude it (y/n):  "| tee -a $qlog
			read graphics

		if [ "$graphics" != "y" -a "$graphics" != "Y" ] ; then
			printf "%b" "\nInstaller will skip install of drm-kmod, and only install Xorg. You then" \
			"\nmust manually configure your jail's packages, and /etc/devfs.rules."  | tee -a $qlog
			jailpkgs="Xorg"	
		else
			printf "%b" "\nInstaller will install drm-kmod along with Xorg"   | tee -a $qlog
			jailpkgs="Xorg $drmkmod"
		fi
	fi

	printf "%b" "\n\nOther common useful packages for guijails include: \n\t" \
		"$xtrapkgs" \
		"\n\nWould you like these all to be installed as well? (y/n):  "
	read addtlpkgs

		if [ "$addtlpkgs" != "y" -a "$addtlpkgs" != "Y" ] ; then
		   	printf "%b" "\n\nInstaller will not include these"
		else
			jailpkgs="$jailpkgs $xtrapkgs"
		fi

	printf "%b" "\n\nThe final state of packages to be installed is as follows:" \
		"\n\n\t0net (the network rootjail) will receive:  wireguard wireguard-go jq" \
		"\n\n\t0gui (the gui rootjail) will receive:" \
		"\n\t\t$jailpkgs\n"  | tee -a $qlog

	printf "%b" "\n\nPRESS {ENTER} TO CONTINUE CONTINUE WITH PACKAGE INSTALLATION." 
	read cont

	clear

	printf "%b" "\n\nStarting 0net and 0gui jails for pkg installaion"
	jail -c 0net  >> $qlog 
	jail -c 0gui  >> $qlog 

	chroot ${m_jails}/0net /usr/sbin/pkg install --yes wireguard wireguard-go jq
	chroot ${m_jails}/0gui /usr/sbin/pkg install --yes $jailpkgs

	# net-jails need VPN scripts
	cp /usr/local/bin/qb-ivpn ${m_jails}/0net/usr/local/bin/

	# Gui jails need the .X11-unix , and home directories in order to nullfs the mount later
	mkdir ${m_jails}/0gui/tmp/.X11-unix
	mkdir ${m_jails}/0gui/home

	# New tyme to make sure that the new snapshot is different from send/recv  
	tyme=$(date +%H%M)
	zfs snapshot "${jails_zfs}/0net@${date}_${tyme}"  
	zfs snapshot "${jails_zfs}/0gui@${date}_${tyme}" 
	zfs snapshot "${zusr_zfs}/0gui-template@${date}_${tyme}"

	clear

	printf "%b" "\n\nPACKAGES INSTALLED. DATASETS SNAPSHOT." \
		"\nJails setup is now complete"
	
	echo "ROOTJAIL_PACKAGES_FINISHED"  >> $qlog
}

reboot_prepare() {
	echo "REBOOT_PREPARE_STARTING"  >> $qlog
	
	if [ -n "$fetchpid" ] ; then 
		if `ps "$fetchpid" | grep -qs "$fetchpid"` ; then
			printf "%b" "Ready to move on to nicvm and usbvm install/configuration, " \
				"but still waiting on the $BSDiso to download."  | tee -a $qlog
			while : ; do
				if `ps "$fetchpid" | grep -qs "$fetchpid"` ; then
					prog=$(du -h /usr/local/share/FreeBSD-13.0-RELEASE-amd64-bootonly.iso | \
						awk '{print $1}' | tee -a $qlog)
					printf "%b" "\n$prog of 162M Downloaded ... "
					sleep 5
				else
					break
				fi
			done
		fi
	else
		if ! [ -e "/usr/local/share/${BSDiso}" ] ; then
			printf "%b" "\n\nSystem needs to reboot, but, there was a problem with downloading" \
			"the \nboot iso, which needs to be saved at /usr/local/share/ for VM setup" \
			"\n\nYou can retry the download in a separate console with this command: " \
			"\nfetch -aq -o /usr/local/share/ http://ftp4.freebsd.org/pub/FreeBSD/releases/" \
			"ISO-IMAGES/13.0/${BSDiso}" \
			"\n\n\Once the full iso is saved; you can reboot; re-run this script; " \
			"\nand the installer will pick up where it left off at this step." \
			"\n\nInstaller exiting now. Press {ENTER} to exit"
			read cont
			exit 0
		fi
	fi
	
	# Remove the ifconfig line from rc.conf
	sed -i '' -E "/ifconfig_/ d" /etc/rc.conf

	printf "%b" "\n\nReboot is required for PCI passthrough to take effect." \
		"\nAfter reboot, RUN THIS INSTALLER SCRIPT AGAIN, which will continue from this point" \
		"\n\nPress {ENTER} to reboot" 
	read cont

	echo "REBOOT_PREPARE_FINISHED"  >> $qlog

	reboot
	printf "%b" "\n... rebooting ..."
	sleep 2
}

nicvm_install() {
	echo "NICVM_INSTALL_STARTING" >> $qlog 2>&1

	# Note: nicvm is installed/updated first, then usbvm duplicated from it. This gives usbvm identical settings
	# until adjusted. So nicvm installed first, then usbvm launched/changed, then nicvm rebooted and configured 

	printf "%b" "\nStarting installer for nicvm - a bhyve virtual machine for the network card" \
			"\n\nThis requires your inputs to complete. Here are notes on what to select:  "\
			"\n\t- Console type: xterm"\
			"\n\t- Hostname should be:  nicvm"\
			"\n\t- Deselect all system components (debug, 32-bit, ports, test stuff, etc)"\
			"\n\t- Select phyical nic (igb0, em0, wls0, etc)" \
			"\n\t\t-- Do NOT select vtnet0. It's just the virtual interface for the internal network" \
			"\n\t\t-- DHCP. You can manually configure if you want, but it's unnecessary" \
			"\n\t- AutoZFS ; 0 swap ; stripe vtbd0" \
			"\n\t- Set a good password.  nicvm is entrance point into your computer from the outside" \
			"\n\t- SELECT SSHD!, Will be the primary access method into the VMs. Deslect others" \
			"\n\t- Select all system hardening options" \
			"\n\t- No users" \
			"\n\t- Exit, BUT DON'T REBOOT -Manual Configuration- Open a shell and copy EXACTLY these commands" \
			"\n\t\tsysrc ifconfig_vtnet0=\"inet $nicIP1/24\"" \
			"\n\t\tsed -i \'\' -e \"s/\#PermitRootLogin no/PermitRootLogin yes/\"  /etc/ssh/sshd_config" \
			"\n\t\tfreebsd-update fetch install" \
			"\n\t\texit" \
			"\n\t- Then you can reboot the VM. Press \"4\" on the reboot screen to exit" \
			"\n\n\t(HINT: highlight text with mouse, switch back to main TTYV, then shift+insert to paste text)" \
			"\n\nTo see these commands again, switch TTYVs and run this script again." \
			"\n\t(the installer checks to see that you're at this step)" \
			"\n\n\t{ENTER} TO CONTINUE"
	read cont
	zfs create -V2G -o volmode=dev ${zroot}/nicvm

	printf "%b" "\nCreated zfs volume for basevm"
	sh /usr/share/examples/bhyve/vmrun.sh -c 1 -m 600M -p $nicnum -t tap0 -d /dev/zvol/${zroot}/nicvm -i -I /usr/local/share/${BSDiso} nicvm

	printf "%b" "\n\n\nINTIAL nicvm INSTALL COMPLETED. The qubsd-installer script must exit to clean" \
		"\nthe shell environment. Restart the script, and it will continue from here." \
		"\n\n\t/usr/local/bin/qubsd-installer  \n\n"

	echo "NICVM_INSTALL_FINISHED" >> $qlog 2>&1
	exit 0
}

usbvm_configure() {
	echo "VMS_CONFIGURE_STARTING" >> $qlog 2>&1

	printf "%b" "\n\n... continuing ...\n" \
			"\nTaking snapshot of nicvm and sending it to $zroot/usbvm " \
			"\nThis could take 60 seconds or more"

	nicsnap="${zroot}/nicvm@${date}_${tyme}"
		zfs snapshot $nicsnap 
		zfs send $nicsnap | zfs recv ${zroot}/usbvm

	clear
		printf "%b" "\n\nStarting both nicvm and usbvm. This will take another 60 seconds" 

	service nicvm onestart &
	sleep 2
		service usbvm onestart & 
		sleep 2

	printf "%b" "\n\nWaiting for VMs to boot, then SSH will be used for access and configuration." \
			"\nTHE NICVM SSH KEY IS SECURITY CRITICAL! It confers access to your system from the outside." \
			"\nIt will be stored only on net-firewall, as the net-<jails> are considered secure." \
			"\n\nThe usbvm SSH key is low security risk, as it stays offline except for updates. Key will" \
			"\nbe copied to 0gui-template and 0net-template, so appjails can access usb storage devices." \
			"\n\n\tnote: installer will wait 60 more seconds for VMs to boot, before proceeding.\n\t"

	sleeping="60"
	while [ "$sleeping" -gt 0 ] ; do
		printf "%b" "... $sleeping "
		sleep 5
		sleeping=$(( sleeping - 5 ))
	done	
	
	pfctl -f /etc/pf_pass.conf
	ifconfig tap1 inet $nicIP2 up   

	printf "%b" "\n\nGenerating SSH keys for usbvm (No password. Again, low security risk, internal use only)" \
			"\nRemember that we duplicated the nicvm dataset, so even though this is for the usbvm, it will" \
			"\nbe labeled as nicvm on the prompts until we reboot and the VM hostname change takes effect.\n\n"

	ssh-keygen -f /root/.ssh/usbvm -P ""
	ssh-copy-id -i /root/.ssh/usbvm root@$nicIP1 

	if [ "$?" != "0" ] ; then  
		printf "%b" "If the connection was refused, sometimes the DHCP client can hang directly after VM" \
			"\ninstall, and will retry for 1 - 2 mins. A system reboot will fix this, but for now, will" \
			"\nretry SSH every 15 seconds until successful. Will reboot after VM configs are complete" 
		while : ; do
			sleep 15
			ssh-copy-id -o StrictHostKeyChecking=no -i /root/.ssh/usbvm root@$nicIP1 
			[ "$?" = "0" ] && break
		done
	fi
		
	scp -o StrictHostKeyChecking=no -i /root/.ssh/usbvm ${m_jails}/quBSD/zroot/usbvm/* root@${nicIP1}:/root
	ssh -o StrictHostKeyChecking=no -i /root/.ssh/usbvm root@${nicIP1} \
									'mv /root/loader.conf /boot/ \
									;mv /root/sshd_config /etc/ssh/ \
									;mv /root/rc.conf /etc/ \
									;mv /root/resolv.conf /etc/ \
									;mv /root/sysctl.conf /etc/'

	# IP needs to be managed between tap1 and tap0; since usbvm changed IP needs a reboot to take effect
	ifconfig tap1 -alias
	ifconfig tap0 inet $nicIP2 up
	[ -e "${m_zusr}/0gui-template/rw/root/.ssh" ] || mkdir -p "${m_zusr}/0gui-template/rw/root/.ssh" ] 
	mv /root/.ssh/* ${m_zusr}/0gui-template/rw/root/.ssh

	printf "%b" "\n\nKeys/configs pushed to USBVM. You probably still want to install pkgs for mounting" \
		"\next4 (Linux) USBs; and/or for mounting Android phones, but will do that later.\n\n" \
		"Press {ENTER} to continue"
		read cont
}

nicvm_configure() {

	clear
	printf "%b" "\nNow configuring nicvm. Set a good password for nicvm SSH (can be same as nicvm root passwd)\n\n"

	ssh-keygen -f /root/.ssh/nicvm 
	ssh-copy-id -o StrictHostKeyChecking=no -i /root/.ssh/nicvm root@$nicIP1 

	if [ "$?" != "0" ] ; then  
		printf "%b" "\n\nIf the connection was refused, sometimes the DHCP client can hang, directly after VM" \
			"\ninstall, and will retry for 1 - 2 mins. A system reboot will fix this, but for now, will" \
			"\nretry SSH every 15 seconds until successful. Will reboot after VM configs are complete" 

		while : ; do
			sleep 15
			echo ""
			ssh-copy-id -i /root/.ssh/nicvm root@$nicIP1 
			[ "$?" = "0" ] && break
		done
	fi

	printf "%b" "\n\nKey push done. Approve the prompts with password for nicvm and SSH key, (a few times)\n"

	scp -o StrictHostKeyChecking=no -i /root/.ssh/nicvm ${m_jails}/quBSD/zroot/nicvm/* root@${nicIP1}:/root
	ssh -o StrictHostKeyChecking=no -i /root/.ssh/nicvm root@${nicIP1} \
									'mv /root/loader.conf /boot/ \
									;mv /root/pf.conf /etc/ \
									;mv /root/sshd_config /etc/ssh/ \
									;cat /root/rc.conf | xargs sysrc \
									;rm /root/rc.conf'

	printf "%b" "\n\nnicvm is configured, but it still needs to be hardened: schg flags for system files," \
		"\nand secure level 3. However, likely you need to set pf.conf to your personal requirements." \
		"\n\nUse net-firewall for future access to the nicvm. \n\nPress {Enter} to continue... \n"
		read cont

	clear

	# Move keys to net-firewall jail
	[ -e "${m_zusr}/0net-template/rw/root/.ssh" ] || mkdir -p "${m_zusr}/0net-template/rw/root/.ssh" ] 
	mv /root/.ssh/* ${m_zusr}/net-firewall/rw/root/.ssh/

	printf "%b" "\n\nAdjusting sysrc to launch nicvm and usbvm at boot\n"
	sysrc nicvm_enable="YES"
	sysrc usbvm_enable="YES"

	printf "%b" "\nquBSD install has completed all essential configurations. System is ready for use!" \
		"\nHighly recommend going through the tutorial at: /usr/local/share/quBSD/1_TUTORIAL" \
		"\n\nSYSTEM NEEDS TO REBOOT ONE LAST TIME for the VM changes to take effect" \
		"\n\tPress {ENTER} to REBOOT."
	read cont

	echo "NICVM_CONFIGURE_FINISHED" >> $qlog 2>&1
	echo "INSTALLATION_COMPLETE" >> $qlog 2>&1
	
	reboot
	printf "%b" "\n... rebooting ..."
	sleep 2
	exit 0
}

reboot_checks() {
	clear 

	pcidevice_variables

	if  `tail -1 $qlog | grep -qs "NICVM_INSTALL_STARTING"` ; then 
		printf "%b" "\nStarting installer for nicvm - a bhyve virtual machine for the network card" \
			"\n\nThis requires your inputs to complete. Here are notes on what to select:  "\
			"\n\t- Console type: xterm"\
			"\n\t- Hostname should be:  nicvm"\
			"\n\t- Deselect all system components (debug, 32-bit, ports, test stuff, etc)"\
			"\n\t- Select phyical nic (igb0, em0, wls0, etc)" \
			"\n\t\t-- Do NOT select vtnet0. It's just the virtual interface for the internal network" \
			"\n\t\t-- DHCP. You can manually configure if you want, but it's unnecessary" \
			"\n\t- AutoZFS ; 0 swap ; stripe vtbd0" \
			"\n\t- Set a good password.  nicvm is entrance point into your computer from the outside" \
			"\n\t- SELECT SSHD!, Will be the primary access method into the VMs. Deslect others" \
			"\n\t- Select all system hardening options" \
			"\n\t- No users" \
			"\n\t- Exit, BUT DON'T REBOOT -Manual Configuration- Open a shell and copy EXACTLY these commands" \
			"\n\t\tsysrc ifconfig_vtnet0=\"inet $nicIP1/24\"" \
			"\n\t\tsed -i \'\' -e \"s/\#PermitRootLogin no/PermitRootLogin yes/\"  /etc/ssh/sshd_config" \
			"\n\t\tfreebsd-update fetch install" \
			"\n\t\texit" \
			"\n\t- Then you can reboot the VM. Press \"4\" on the reboot screen to exit" \
			"\n\n\t(HINT: highlight text with mouse, switch back to main TTYV, then shift+insert to paste text)" \
                	"\n\n\t{ENTER} TO CONTINUE"
		read cont

		if `ps aux | grep -qs "/usr/local/bin/qubsd-installer"` ; then
			printf "%b" "\nAnother instance of this script is already running. Exiting\n\n"
			exit 0
		fi
	fi

	printf "%b" "\n\nWelcome back to the quBSD installer script. It looks like you left off after " \
		"\nneeding a reboot. Continue with the installer? (\"no\" for rollback options) (y/n):  "
		read resp
	if [ "$resp" != "y" -a "$resp" != "Y" ] ; then
		state="postjails"
		state_rollback
	fi

	if [ "$state" = "rebootchecks" ] ; then	
		nicnum=$(sed -n "s/^nicnum=//p" $qlog)
		if [ -z "$nicnum" ] ; then
			printf "%b" "\nERROR: Unable to find the pptdev previously selected for the nicvm" \
			"\nWill send you to the rollback options page. Be sure that after re-doing the " \
			"\ninstall, that you don't modify the logfile at /var/log/qubsd-install_log" \
			"\n\nPress {Enter} to continue" ; read cont
			state="postjails"
			state_rollback
		elif ! [ -e "/usr/local/share/${BSDiso}" ] ; then 
			printf "%b" "\nIt appears that you have rebooted and the PCI devices are appropriately" \
                        "\ndesignated for passthrough. However, the ISO file is not found at\n " \
                        "/usr/local/share. Please download the file and try again.\n\n\t\t" \
"fetch -aq -o /usr/local/share/ http://ftp4.freebsd.org/pub/FreeBSD/releases/ISO-IMAGES/13.0/${BSDiso}\n" \
			exit 1
        	fi
	fi
	state_VM_configure
}

state_rollback() {
	clear
	qusnaps=$(zfs list -rt snapshot | egrep "@quBSD_" )

	printf "%b" "\nIt appears that the script may have terminated at an intermediate state." \
			"\nYou will be provided options for rolling back the install."
		
	printf "%b" "\n\nHere are the snapshots quBSD took of your system before starting\n" \
			"\n$qusnaps"

	printf "%b" "\n\nAnd here are the current quBSD related datasets that can be destroyed\n"
		zfs list -rt all $zroot
		zfs list -rt all $zusr_zfs

	if `echo "$state" | egrep -qs "complete|midvms|nicvminstalled|rebootchecks"`  ; then
		printf "%b" "\nIt appears that you may have a sucessful install of quBSD virtual machines." \
			"\nWould you like to destroy the VMs, and revert any settings made? (y/n):  "
		read resp 
		if [ "$resp" = "y" -o "$resp" = "Y" ] ; then
			rollback1="true" 
		else 	printf "%b" "\nNothing to do then. Exiting.\n\n" ; exit 0
		fi

		printf "%b" "\nWould you like to also rollback the jails install? (y/n):  "
		read resp 
		if [ "$resp" = "y" -o "$resp" = "Y" ] ; then
			rollback2="true" 
		else	printf "%b" "\nOkay, just the VMs portion will be rolled back. {Enter} to continue"
			read cont
		fi

	elif `zfs list -rt all ${zroot} | grep -qs "(${zroot}/nicvm|${zroot}/usbvm)"` ; then
		printf "%b" "\nEven though the log doesn't seem to show it, there appears to be datasets" \
			"corresponding the nicvm and/or usbvm. In which case, would you like to destroy" \
			"the VM datasets and revert any settings that may be associated with them? (y/n):  "
		read resp 
		if [ "$resp" = "y" -o "$resp" = "Y" ] ; then
			rollback1="true" 
		else 	printf "%b" "\nNothing to do then. Exiting.\n\n" ; exit 0
		fi

		printf "%b" "\nWould you like to also rollback the jails install? (y/n):  "
		read resp 
		if [ "$resp" = "y" -o "$resp" = "Y" ] ; then
			rollback2="true" 
		else	printf "%b" "\nOkay, just the VMs portion will be rolled back. {Enter} to continue"
			read cont
		fi

	elif `echo "$state" | egrep -qs "midcopy|snapscomplete"` ; then
		printf "%b" "\nIt appears that you were in the middle of jails-install. \nWould you " \
			"like to remove those jails and rollback to the snapshots available?  (y/n):  "
		read resp 
		if [ "$resp" = "y" -o "$resp" = "Y" ] ; then 
			rollback2="true"
		else 	printf "%b" "\nNothing to do then. Exiting.\n\n" ; exit 0
		fi

	elif `echo "$state" | egrep -qs "halfsnapped|dubious"` ; then
		printf "%b" "\nIt appears that there may have been an error in the middle of attempting " \
			"to create initial snapshots; but before writing over any files. Would you like" \
			"to rollback whatever is available? (y/n):  "
		read resp 
		if [ "$resp" = "y" -o "$resp" = "Y" ] ; then 
			rollback2="true" 
		else 	printf "%b" "\nNothing to do then. Exiting.\n\n" ; exit 0
		fi
	fi

	if [ "$rollback1" ] ; then
		printf "%b" "\nThe installer will destroy any VMs and revert any associated settings." \
			"\nThis involves: the following commands:" \
			"\n\nremoving all jails" \
			"\nbhyvectl --force-poweroff --vm=usbvm and nicvm" \
			"\nbhyvectl --destroy --vm=usbvm and nicvm" \
			"\nbhyvectl --destroy --vm=usbvm and nicvm" \
			"\nzfs destroy ${zroot}/usbvm and nicvm" \
			"\nifconfig tap1 and tap2 destroy" \
			"\nrm -r /root/.ssh ... from host, and multiple jails" \
			"\nAnd reverting nicvm/usbvm services at boot" \
			"\n\nThis will lock up stdio and all system inputs for about 10-20 seconds." \
			"\n\tReady to proceed? (y/n):  "
			read resp
			if [ "$resp" != "y" -a "$resp" != "Y" ] ;then 
				printf "%b" "\nNothing to do then. Exiting.\n\n" ; exit 0
			fi

		qb-off -a
		bhyvectl --force-poweroff --vm=usbvm	
		bhyvectl --force-poweroff --vm=nicvm
		bhyvectl --destroy --vm=usbvm	
		bhyvectl --destroy --vm=nicvm
		zfs destroy -rRf ${zroot}/usbvm
		zfs destroy -rRf ${zroot}/nicvm
		ifconfig tap1 destroy
		ifconfig tap0 destroy
		rm -r /root/.ssh/nicvm*
		rm -r /root/.ssh/usbvm*
		rm -r ${m_zusr}/net-firewall/rw/root/.ssh/*
		rm -r ${m_zusr}/0gui-template/rw/root/.ssh/*
		rm -r ${m_zusr}/0net-template/rw/root/.ssh/*
		sysrc usbvm_enable="NO"
		sysrc nicvm_enable="NO"
		
		sed '/REBOOT_PREPARE_FINISHED/,$ d' $qlog 
		echo 'REBOOT_PREPARE_FINISHED' >> $qlog
	fi

	if [ "$rollback2" ] ; then
		printf "%b" "\nThe installer will now destroy any datasets specific to quBSD jails, " \
			"\nand rollback any pre-install snapshots that were taken." \
			"\n\tReady to proceed? (y/n):  "
			read resp
			if [ "$resp" != "y" -a "$resp" != "Y" ] ;then 
				printf "%b" "\nNothing to do then. Exiting.\n\n" ; exit 0
			fi

		jail -r 0base
		jail -r 0net
		jail -r 0gui
		jail -r 0net-template
		jail -r 0gui-template
		jail -r net-tap
		jail -r net-firewall
		jail -r net-vpn
		jail -r dispjail

		zfs destroy -rRf ${zroot}

		echo "$qusnaps" | awk '{print $1}' | xargs -I@ zfs rollback -R @
		echo "$qusnaps" | awk '{print $1}' | xargs -I@ zfs destroy -rRf @
		rm $qlog
	fi
	
	printf "%b" "\n\nRollback is now complete, and the log at /var/log/qubsd_install_log has been removed" \
		"\n\nIf you want to try again, recommend rebooting, and run the installer again.\n\n"

	exit 0
}
		
state_determine() {
	if [ -e $qlog ] ; then
		if `grep -qs "INSTALLATION_COMPLETE" $qlog` ; then 
			printf "%b" "\nLog shows that installation appears to be complete." \
					"\nDo you want to try and rollback to a previous state? (y/n):  "
			read resp

			if [ "$resp" != "y" -a "$resp" != "Y" ] ; then
				printf "%b" "\nNothing to do then. Exiting.\n\n" ; exit 0
			else 
				state="complete"
				state_rollback
			fi

		elif  `grep -qs "USBVM_CONFIGURE_STARTING" $qlog` ; then state="midvms" && state_rollback 
		elif  `tail -1 $qlog | grep -qs "NICVM_INSTALL_FINISHED"` ; then state="nicvminstalled" && state_VM_configure
		elif  `grep -qs "REBOOT_PREPARE_FINISHED" $qlog` ; then state="rebootchecks" && reboot_checks 
		elif  `grep -qs "REBOOT_PREPARE_STARTING" $qlog` ; then state="rebootchecks" && reboot_checks 
		elif  `grep -qs "QUBSD_FILES_COPY_STARTING" $qlog` ; then state="midcopy" && state_rollback
		elif  `grep -qs "DATASETS_PREPARE_FINISHED" $qlog` ; then state="snapscomplete" && state_rollback
		elif  `grep -qs "DATASETS_PREPARE_STARTING" $qlog` ; then state="halfsnapped" && state_rollback
		elif [ -e "$qlog" -a -e "/root/old_configs" ] ; then state="dubious" && state_rollback
		fi   
		else state_fresh
	fi
}

state_fresh() {
	preinstall_confirmation
	datasets_prepare	
	qubsd_files_copy
	pptdevs_selection_loop
	qubsd_files_modify
	rootjails_installation
	rootjails_packages
	reboot_prepare
}

state_VM_configure() {
	pcidevice_variables	
	[ "$state" = "nicvminstalled" ] || nicvm_install
	usbvm_configure 
	nicvm_configure 
}

preinstall_variables
state_determine


