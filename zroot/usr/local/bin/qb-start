#!/bin/sh

# Starting jails in parallel comes with race-condition problems.
	# Overlapping starts of a shared gateway can lock the system
	# auto IP assignments will likely overlap unless managed ahead of time
	# Epair race conditions and mishandling between gateway/client
# This script deconflicts these, starting jails in serial when necessary, parallel if possible

. /usr/local/lib/quBSD/quBSD.sh
. /usr/local/lib/quBSD/msg-start.sh

get_options() {
	while getopts aAeE:hf:t: opts ; do case $opts in
		a) _SOURCE="auto" ;;
		A) [ "$_SOURCE" ]  && msg_start -Eum _e1 || _SOURCE="all" ;;
		e) _EXCLUDE="true" ;;
		E) [ "$_EXCLUDE" ] && msg_start -Eum _e2 || _EXFILE="$OPTARG" ;;
		f) [ "$_SOURCE" ]  && msg_start -Eum _e1 || _SOURCE="$OPTARG" ;;
		h) msg_start -eu ;;
		t) _TIMEOUT="$OPTARG" ;;
		*) exit 1 ;;
	esac  ;  done  ;  shift $(( OPTIND - 1 ))

	# This makes it so that _POSPARAMS has one parameter per line
	_POSPARAMS=$(printf '%s\n' "$@" | uniq)

	# Temp files for locking, timeouts, and IP resolution
	_TMP_LOCK="${QTMP}/.qb-startstop_lock"
	_TMP_TIME="${QTMP}/.qb-startstop_timeout"
	_TMP_IP="${QTMP}/.qb-start_temp_ip"
}

checks() {
	# Check validity of TIMEOUT
	[ "$_TIMEOUT" ] && ! chk_integer -g 5 -l 600 -q -- "$_TIMEOUT" \
																		&& msg_start -Em _e5
	# Trap function
	trap "cleanup_trapped" INT HUP TERM QUIT EXIT

	# Ping check if qb-start may continue, get placed in queue, or exit if timeout happens
	monitor_startstop -p || msg_start -Em _e0
}

echo_grep() {
	# Too many echo | greps looks dirty. Put into a function
	echo "$1" | grep -Eqs "(^|[[:blank:]]+)${2}([[:blank:]]+|\$)" && return 0 || return 1
}

climb_hierarchy() {
	# Trickiest part is calulating the number of hierarchy levels that need to start. The full
	# hierarchy path is resolved recursively, and as it unwinds at the end, _starts are tallied

	# Prevent infinite loop. Unlikely to be 10 gateways; more likely circular reference
	[ "$_depth" -gt 10 ] && msg_start -Em _e3
	_depth=$(( _depth + 1 ))

	# JAIL gateway path was already handled. Skip further checks.
	local _JAIL="$1"
	echo_grep "$_CLIMBED" "$_JAIL" && return 0

	# JAIL has not been handled yet. Add count to starts; add to FULLIST, and CLIMBED
	_CLIMBED=$(printf "%b" "${_JAIL}\n${_CLIMBED}")
	_FULLIST=$(printf "%b" "${_FULLIST}\n${_JAIL}")

	# Disposition JAIL based on _gateway, and also identify its control jail for ordered start
	local _gateway=$(get_jail_parameter -deqsz GATEWAY "$_JAIL")
	local _control=$(get_jail_parameter -deqsz CONTROL $_JAIL)
	_CJAILS="$(printf "%b" "${_control}\n${_CJAILS}")"

	if [ "$_gateway" = "none" ] || [ -z "$_gateway" ] ; then
		# JAIL is an endpoint. Either has no network, or is top of hierarchy.
		_HIERTOP=$(printf "%b" "${_JAIL}\n${_HIERTOP}")
	else
		# If _gw was already climbed, then we'll exit here, but need to add its _starts to _JAIL
		if _gw_st=$(echo "$_CLIMBED" | grep -E "^$_gateway " | grep -Eo ' [[:digit:]]+$') ; then
			_starts=$_gw_st
			_CLIMBED=$(echo "$_CLIMBED" | sed -E "s/^($_JAIL ).*/\1${_starts}/")
		else
			# Continue recursively until hiearchy top is reached
			climb_hierarchy "$_gateway"
	fi fi

	# As the recursive loop unwinds now, count up how many of the hierarchy levels must start
	! chk_isrunning "$_JAIL" && _starts=$(( _starts + 1 ))
	_CLIMBED=$(echo "$_CLIMBED" | sed -E "s/^(${_JAIL})\$/\1 ${_starts}/")
}

encryption_and_mounts(){
   # Load key if necessary, with popup switch 
	if [ "$(zfs list -Ho keystatus ${U_ZFS}/${_jail})" = "unavailable" ] ; then
		if [ "$_POPUP" ] ; then 
			xterm -e csh -c "/bin/csh -c 'zfs load-key ${U_ZFS}/${_jail}'"
		else
			zfs load-key ${U_ZFS}/${_jail}
		fi
	fi

	# Volumes do not get mounted
	[ "$(zfs list -Ho type ${U_ZFS}/${_jail})" = "filesystem" ] \
		&& [ "$(zfs list -Ho mounted ${U_ZFS}/${_jail})" = "no" ] \
		&& zfs mount ${U_ZFS}/${_jail}
}

determine_ips() {
	# Map IPs in serial, write to TMP
	for _jail in $_FULLIST ; do
		# Only get IPs for offjails
		if ! chk_isrunning "$_jail" ; then

			# IP calculations for 0control and jail networking. Skip hierarchy tops
			printf "%b" "$_jail SSH $(discover_open_ipv4 -t SSH $_jail)\n" >> $_TMP_IP

			! echo_grep "$_HIERTOP" "$_jail" \
					&& printf "%b" "$_jail NET $(discover_open_ipv4 -t NET $_jail)\n" >> $_TMP_IP
		fi
	done
}

begin_waterfall() {
	_JAILS="$1"
	for _JAIL in $_JAILS; do
		# Only continue the waterfall if jail started successfully
		start_jail -q "$_JAIL" 2>&1 || msg_start -Em _e4

		# Determine ENDPOINTS and SUBGATEWAYS (reset the values for each waterfall recursion)
		_SUBGATEWAYS='' ; _ENDPOINTS=''
		for _client in $(get_info -e _CLIENTS $_JAIL); do

			# Check that _client is on the FULLIST (save time)
			if echo_grep "$_FULLIST" "$_client" ; then
				# If the _client has no further clients, it returns 1, and is an ENDPOINT
				get_info _CLIENTS "$_client" \
					&& _SUBGATEWAYS="$_SUBGATEWAYS $_client" \
					|| _ENDPOINTS="$_ENDPOINTS $_client"
			fi
		done

		# Start each endpoint
		for _end in $_ENDPOINTS ; do
			# Maintain a small stagger between parallel starts. Helps prevent conflicts
			sleep .1
			start_jail -q $_end 2>&1 &
			_SJ_PIDS="$_SJ_PIDS $!"
		done

		# Subgateways need their own waterfall
		for _subgateway in $_SUBGATEWAYS ; do
			begin_waterfall "$_subgateway" &
			_SW_PIDS="$_SW_PIDS $!"
		done
	done

	# Wait for all of the start_jail sent to background to finish
	ps -p "$_SJ_PIDS $_SW_PIDS" > /dev/null 2>&1 && wait $_SJ_PIDS $_SW_PIDS
	return 0
}

cleanup_trapped() {
	# Immediately kill the monitoring PID, to help prevent any races for cleanup
	ps -p $_MONITOR_PID > /dev/null 2>&1 && kill -9 $_MONITOR_PID

	# Remove PID from the lock file. If it's empty, all tmp files can be removed
	if [ -e "$_TMP_LOCK" ] ; then
		sed -i '' -E "/^$$\$/ d" $_TMP_LOCK
		[ ! -s "$_TMP_LOCK" ] && rm $_TMP_LOCK $_TMP_IP $_TMP_TIME $_TMP_PIDS > /dev/null 2>&1
	fi
}

main() {
	# Returns $_JLIST, from options and positional arguments. Func shared with qb-start.
	compile_jlist

	# Find gateway hierarchy top for each jail. Returns global vars: _CJAILS _HIERTOP _FULLIST
	for _jlist in $_JLIST ; do
		# Function is recursive, so _depth tracks # of recursions to prevent infinite loop
		_depth=0 ; _starts=0
		climb_hierarchy "$_jlist"
	done

	# Set and/or cleanup variables from the climb_hierarcy loop
	_HIERTOP=$(echo "$_HIERTOP" | sort | uniq)
	_FULLIST=$(echo "$_FULLIST" | sort | uniq)
	_STARTS=$(echo "$_CLIMBED" | awk 'NR == 1 || $2 > max { max = $2 } END { print max }')

	# Some jails/VMs might be encrypted. They need to decrypted now, before waterfall 
	get_info _POPUP	
	for _jail in $_FULLIST ; do 
		encryption_and_mounts
	done

	# IP addr are mapped out ahead of time to prevent overlaps during parallel start
	determine_ips

	# Control jails must be started first
	for _cjail in $(echo "$_CJAILS" | sort | uniq) ; do
		start_jail $_cjail
	done

	# Start the hierarchy tops, then their clients, until all of FULLIST is started
	for _jail in $_HIERTOP ; do
		# Each hierarchy top is independent of each other, and can be started in parallel.
		begin_waterfall $_jail &
		_WF_PIDS="$_WF_PIDS $!"
	done

	# STARTS keeps track of the number of hierchy levels. If 0, there was nothing to start
	[ "$_STARTS" = 0 ] && msg_start -m _m2

	# User specified timeout, or use 5 seconds for every hierarchy level
	monitor_startstop "${_TIMEOUT:=$(( _STARTS * 10))}" &
	_MONITOR_PID="$!"

	# Wait for starts to finish. If TIMEOUT, monitor_startstop will kill -15 this script
	ps -p $_WF_PIDS > /dev/null 2>&1 && wait $_WF_PIDS
	msg_start -m _m1

	# Remove /tmp files and kill monitoring process
	cleanup_trapped
}


get_global_variables

get_networking_variables

get_options "$@"

checks

main
