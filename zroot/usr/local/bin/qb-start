#!/bin/sh

# Starting jails in parallel comes with race-condition type problems.
	# Overlapping starts of a shared gateway can lock the system
	# auto IP assignments will likely overlap unless managed ahead of time
	# Epair race conditions and mishandling between gateway/client

# This script deconflicts these, starting jails in serial when necessary, parallel if possible


. /usr/local/lib/quBSD/quBSD.sh
. /usr/local/lib/quBSD/msg-start.sh

get_options() {
	while getopts aAeE:f:ht: opts ; do
		case $opts in
			a) _SOURCE="auto" ;;
			A) [ "$_SOURCE" ] && get_msg_start "_e1" "usage_1" || _SOURCE="all" ;;
			e) _EXCLUDE="true" ;;
			E) [ "$_EXCLUDE" ] && get_msg_start "_e2" "usage_1" || _EXFILE="$OPTARG" ;;
			f) [ "$_SOURCE" ] && get_msg_start "_e1" "usage_1" || _SOURCE="$OPTARG" ;; 
			h) get_msg_start "none" "usage_0" ;;
			t) _TIMEOUT="$OPTARG" ;; 
			*) exit 1 ;;
		esac
	done

	shift $(( OPTIND - 1 ))

	# This makes it so that _POSPARAMS has one parameter per line
	_POSPARAMS=$(printf '%s\n' "$@" | uniq)
	_TIMEOUT="${_TIMEOUT:=60}"
}

checks() {

	# Timeout must be an integer less than 300 and greater than 5
	if echo "$_TIMEOUT" | ! grep -Eq '^[[:digit:]]+$' \
			|| [ "$_TIMEOUT" -gt 300 ] || [ "$_TIMEOUT" -lt 5 ]
	then 
		get_msg_start "_e5" "usage_1"
	fi
	
	# Temp file for IP tracking
	_TMP_IP="${QTMP}/qb-start_temp_ip"

	# Absolutely do not run if another instance if qb-start or qb-stop is already running
	monitor_startstop "1" || get_msg_start "_e0" "exit_1"

	# Function above removes the temp_ip tracker
	mktemp "$_TMP_IP" > /dev/null 2>&1
}

reclone_stale_zroots() {

	# Pull the list of zroot datasets
	_datasets=$(zfs list -rHo name,origin ${JAILS_ZFS} | grep -Ev "[[:blank:]]+\-" \
					| awk '{print $1}' | sed -E "s#${JAILS_ZFS}/##g")

	# Check all of them one by one
	for _jail in $_datasets ; do

		# Only reclone the dataset if it's not already on the _JLIST to be started
		if ! echo "$_JLIST" | grep -Eq "$_jail" ; then
			
			# The reclone function needs the rootjail name, not the dataset
			_rootzfs=$(zfs list -rHo origin ${JAILS_ZFS}/${_jail} | sed "s/@.*//g")

			reclone_zroot "${_jail}" "${_rootzfs##*/}"
		fi
	done
}

climb_hierarchy() {

	# Prevent infinite loop. Unlikely to be 50 gateways; more likely circular reference.
	[ "$_depth" -gt 50 ] && get_msg_start "_e3" "exit_1"
	_depth=$(( _depth + 1 ))

	_jail="$1"
	_gateway=$(get_jail_parameter -deqs GATEWAY "$_jail")

	if echo "$_CLIMBED" | grep -Eq "(^|[[:blank:]]+)${_jail}([[:blank:]]+|\$)" ; then 
		# _jail gateway path was already handled. Skip further checks.
		return 0

	# _jail is an endpoint. Either has no network, or is top of hierarchy. 
	elif [ "$_gateway" = "none" ] || [ -z "$_gateway" ] ; then 

		# Assemble list of hierarcy tops. Will later begin starts from this list 
		_HIERTOP=$(printf "%b" "${_jail}\n${_HIERTOP}" | uniq) 

		# Include jail on _FULLIST 
		echo "$_FULLIST" | grep -Eq "(^|[[:blank:]]+)${_jail}([[:blank:]]+|\$)" \
				|| _FULLIST=$(printf "%b" "${_FULLIST}\n${_jail}")

		# Add _jail to the list of jails already climbed and checked.
		_CLIMBED=$(printf "%b" "${_jail}\n${_CLIMBED}") 

	# Make sure _jail is included in FULLIST. (some gateways might not have been on JLIST).
	else
		echo "$_FULLIST" | grep -Eq "(^|[[:blank:]]+)${_jail}([[:blank:]]+|\$)" \
				|| _FULLIST=$(printf "%b" "${_FULLIST}\n${_jail}")

		# Add _jail to the list of jails already climbed and checked.
		_CLIMBED=$(printf "%b" "${_jail}\n${_CLIMBED}") 
	
		# Will continue recursively until hierarchy top is reached	
		climb_hierarchy "$_gateway"
	fi	
}

determine_ips() {

	# Map IPs in serial, write to TMP
	for _jail in $_FULLIST ; do

		# IP calaculation unnecessary for hierchy tops or running jails 
		! chk_isrunning "$_jail" \
			&& ! echo "$_HIERTOP" | grep -Eq "^[[:blank:]]*${_jail}[[:blank:]]*\$" \
				&& printf "%b" "$_jail  $(discover_open_ipv4 $_jail)\n" >> $_TMP_IP
	done
}

begin_waterfall() {

	_JAILS="$1"

	for _JAIL in $_JAILS; do

		# Only continue the waterfall if jail started successfully 
		start_jail "$_JAIL" || get_msg_start "_e4" "exit_1"

		# Determine ENDPOINTS and SUBGATEWAYS (reset the values for each waterfall recursion) 
		_SUBGATEWAYS='' ; _ENDPOINTS=''

		for _client in $(get_info -e _CLIENTS $_JAIL); do

			# Check that _client is on the FULLIST (save time)
			if echo "$_FULLIST" | grep -q "$_client" ; then 

				# If the _client has no further clients, it returns 1, and is an ENDPOINT	
				get_info _CLIENTS "$_client" \
					&& _SUBGATEWAYS="$_SUBGATEWAYS $_client" \
					|| _ENDPOINTS="$_ENDPOINTS $_client"
			fi
		done

		# Start each endpoint
		for _end in $_ENDPOINTS ; do

			# Maintain a small stagger between parallel starts. Helps prevent conflicts
			sleep .2
			start_jail $_end &
		done

		# Subgateways need their own waterfall
		[ -n "$_SUBGATEWAYS" ] && begin_waterfall "$_SUBGATEWAYS" 
	done
}

main() {

	# Returns $_JLIST, from options and positional arguments. Func shared with qb-start.
	compile_jlist

# Reclone stale zroot datasets occasionally. Assume that all jails off, is a larger reset
#	[ -z "$(get_info -e _ONJAILS)" ] && reclone_stale_zroots
# get_info _ONJAILS needs to include VMs

	# Find gateway hierarchy top for each jail. Returns $_HIERTOP and $_FULLIST
	for _jlist in $_JLIST ; do

		# Function is recursive, so _depth tracks # of cycles to prevent infinite loop. 
		_depth=1
		climb_hierarchy "$_jlist"
	done

	# If the _FULLIST is empty, there's nothing to do. Remove TMP and exit.
	[ -z "$_FULLIST" ] && rm "$_TMP_IP" && get_msg_start "_m1" && exit 0 

	# IP addr are mapped out ahead of time to prevent overlaps during parallel start
	determine_ips

	# Start the hierarchy tops, then their clients, until all of FULLIST is started 
	for _jail in $_HIERTOP; do

		# Each hierarchy top is independent of each other, and can be started in parallel. 
		begin_waterfall $_jail &
	done
}


get_global_variables

get_networking_variables

get_options "$@"

checks

main

# Monitor completion of qb-start 
monitor_startstop "$_TIMEOUT" "$_TMP_IP" &

exit 0
