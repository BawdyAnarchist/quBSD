#!/bin/sh

### NOTES ###

# Attempting to start multiple jails in parallel comes with many problems.
	# Gateway dependencies cause multiple attempted starts of that gateway, locking the system
	# auto IP assignments can be overlapping unless managed ahead of time (before jail starts)
	# Epair confusion when gateway and client are started simultaneously. 

# This script resolves gateway dependencies and networking parameters. 
# It starts jails in serial when necessary, and in parallel where possible.


. /usr/local/lib/quBSD/quBSD.sh
. /usr/local/lib/quBSD/msg-start.sh

get_options() {
	while getopts aAeE:hf: opts ; do
		case $opts in
			a) _SOURCE="auto" ;;
			A) [ "$_SOURCE" ] && get_msg_start "_e1" "usage_1" || _SOURCE="all" ;;
			e) _EXCLUDE="true" ;;
			E) [ "$_EXCLUDE" ] && get_msg_start "_e2" "usage_1" || _EXFILE="${OPTARG}" ;;
			h) get_msg_start "none" "usage_0" ;;
			f) [ "$_SOURCE" ] && get_msg_start "_e1" "usage_1" || _SOURCE="$OPTARG" ;; 
			*) exit 1
		esac
	done

	shift $(( OPTIND - 1 ))

	# This makes it so that _POSPARAMS has one parameter per line
	_POSPARAMS=$(printf '%s\n' "$@" | uniq)
}

compile_jlist() {

	case "${_SOURCE}" in
		'')
			# If both SOURCE and POSPARAMS are empty, there is no JLIST. 
			[ -z "$_POSPARAMS" ] && get_msg_start "_e4" "usage_1" || _JLIST="$_POSPARAMS"

			# If there was no SOURCE, then [-e] makes the positional params ambiguous 
			[ "$_EXCLUDE" ] && get_msg_start "_e3" "usage_1" 	
		;;  

		auto)	
			# Find jails tagged with autostart in jmap. 
			_JLIST=$(grep -E "autostart[[:blank:]]+true" $JMAP | awk '{print $1}' | uniq)
		;;

		all)	
			# ALL jails from jailmap, except commented lines
			_JLIST=$(awk '{print $1}' $JMAP | sed "/^#/d" | uniq)
		;;
	
		?*)
			# Only possibility remaining is [-f]. Check it exists, and assign JLIST
			[ -e "$_SOURCE" ] && _JLIST=$(tr -s '[:space:]' '\n' < "$_SOURCE" | uniq) \
					|| get_msg_start "_e5" "usage_1"
		;;
	esac

	# If [-e], then the exclude list is just the JLIST, but error if null. 
	[ "$_EXCLUDE" ] && _EXLIST="$_POSPARAMS" && [ -z "$_EXLIST" ] && get_msg_start "_e6" "usage_1" 

	# If [-E], make sure the file exists, and if so, make it the exclude list 
	if [ "$_EXFILE" ] ; then

		[ -e "$_EXFILE" ] && _EXLIST=$(tr -s '[:space:]' '\n' < "$_EXFILE")	\
			|| get_msg_start "_e7" "usage_1"
	fi	

	# Remove any jail on EXLIST, from the JLIST
	for _exlist in $_EXLIST ; do
		_JLIST=$(echo "$_JLIST" | grep -Ev "^[[:blank:]]*${_exlist}[[:blank:]]*\$")
	done

	# Remove any jails that are already running, from JLIST 
	for _jail in $_JLIST ; do
		chk_isrunning "$_jail" \
				&& _JLIST=$(echo "$_JLIST" | grep -Ev "^[[:blank:]]*${_jail}[[:blank:]]*\$")
	done

	# _FULLIST is needed to avoid adding jails to _JLIST during climb_hierarchy() 
	_FULLIST="$_JLIST"
}

climb_hierarchy() {
	# Prevent infinite loop. Unlikely to be 50 gateways; more likely circular reference.
	[ "$_depth" -gt 50 ] && get_msg_start "_8" "exit_1"
	_depth=$(( _depth + 1 ))

	local _jail="$1"
	local _gateway=$(get_jail_parameter -deqs gateway "$_jail")
	local _class_of_gateway=$(get_jail_parameter -deqs class "$_gateway")

	if echo "$_CLIMBED" | grep -Eq "^[[:blank:]]*${_jail}[[:blank:]]*\$" ; then
		# _jail gateway path was already handled. Skip further checks.
		return 0

	# _jail is an endpoint. Either has no network, or is top of hierarchy. 
	elif [ "$_gateway" = "none" ] || [ "$_class_of_gateway" = "VM" ] ; then

		if get_info _CLIENTS $_jail ; then
			# Has clients that need to wait for _jail to start. 
			_HIERTOP=$(printf "%b" "${_jail}\n${_HIERTOP}" | uniq) 

		else
			# _jail has no networking. Can start immediately in the background 
			start_jail $_jail > /dev/null 2>&1 &

			# It can also be removed from the FULLIST, as it's unimportant 
			_FULLIST=$(echo "$_FULLIST" | grep -Ev "^[[:blank:]]*${_jail}[[:blank:]]*\$")	
		fi
		
		# Add _jail to the list of jails already climbed and checked.
		_CLIMBED=$(printf "%b" "${_jail}\n${_CLIMBED}") 

	# _jail depends on a gateway being started ahead of it.
	else
		# Make sure _jail is included in FULLIST. (some gateways might not have been on JLIST).
		echo "$_FULLIST" | grep -Eq "^[[:blank:]]*${_jail}[[:blank:]]*\$" \
				|| _FULLIST=$(printf "%b" "${_FULLIST}\n${_jail}")

		# Add _jail to the list of jails already climbed and checked.
		_CLIMBED=$(printf "%b" "${_jail}\n${_CLIMBED}") 
	
		# Will continue recursively until hierarchy top is reached	
		climb_hierarchy "$_gateway"
	fi	
}

begin_waterfall() {
	local _jail
	local _gateways="$1"

	for _gw in $_gateways ; do
		
		# Only continue the waterfall if jail started successfully
		if start_jail "$_gw" > /dev/null 2>&1 ; then
			
			classify_clients "$_gw"

			[ -n "$_ENDPOINTS" ] && start_jails_in_background "$_ENDPOINTS" &
			[ -n "$_SUBGATEWAYS" ] && begin_waterfall "$_SUBGATEWAYS" 
		fi
	done
}

classify_clients() {
	# Secondary clients of the jail that was just started	
	local _jail="$1"  ;  local _client

	# Must clear these values so they return only relevant jails
	_SUBGATEWAYS='' ; _ENDPOINTS=''

	for _client in $(get_info -e _CLIENTS $_jail); do

		# Must ensure that the jail is part of the FULLIST 
		if echo "$_FULLIST" | grep -q "$_client" ; then 

			if get_info _CLIENTS "$_client" ; then
				# Lis of jails with clients
				_SUBGATEWAYS="$_SUBGATEWAYS $_client"
			else	
				# Endpoints can be parallel/background started
				_ENDPOINTS="$_ENDPOINTS $_client"
			fi
		fi
	done
}

start_jails_in_background() {
	local _jail ;
	local _endpoints="$1"

	for _jail in $_endpoints ; do
		# Maintain a small stagger between parallel starts. Helps prevent conflicts
		sleep .2
		start_jail $_jail > /dev/null 2>&1 &
	done
}

main() {

	# Script should absolutely not be run if another instance exists (see notes on line 5) 
	pgrep -fl '/bin/sh /usr/local/bin/qb-start' && get_msg_start "_e0" "usage_1"

	# Assemble the list of jails tagged for start. 
	compile_jlist

	# TMP file, so that exec.created can access pre-determined IPs during networking ops.
	_TMP_IP="/tmp/qb-start_temp_ip"
	[ -e "$_TMP_IP" ] && rm "$_TMP_IP" > /dev/null 2>&1
	mktemp "$_TMP_IP"	> /dev/null 2>&1

	# For each jail, find the hierarchy top (gateway of its gateway of its gateway ...) 
	for _jlist in $_JLIST ; do
		_depth=1

		# Function is recursive, and adding all jails in the gateway path, to FULLIST 
		climb_hierarchy "$_jlist"
	done

	# Must determine IPV4s ahead of time, in serial, to prevent overlaps.  
	for _jail in $_FULLIST ; do

		# IP calaculation is unnecessary hierchy tops. Otherwise discover IP, and write to TMP
		! chk_isrunning "$_jail" \
				&& ! echo "$_HIERTOP" | grep -Eq "^[[:blank:]]*${_jail}[[:blank:]]*\$" \
				&& printf "%b" "$_jail  $(discover_open_ipv4 $_jail)\n" >> $_TMP_IP
	done

	# Start the hierarchy tops, then their clients, until all of FULLIST is started 
	for _jail in $_HIERTOP; do

		# Each hierarchy top is independent of each other, and can be started in parallel. 
		begin_waterfall $_HIERTOP &
	done
}


get_global_variables

get_options "$@"

main

exit 0
