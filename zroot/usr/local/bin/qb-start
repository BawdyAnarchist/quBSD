#!/bin/sh

# Starting jails in parallel comes with race-condition problems.
	# Overlapping starts of a shared gateway can lock the system
	# auto IP assignments will likely overlap unless managed ahead of time
	# Epair race conditions and mishandling between gateway/client
# This script deconflicts these, starting jails in serial when necessary, parallel if possible

. /usr/local/lib/quBSD/quBSD.sh
. /usr/local/lib/quBSD/msg-start.sh

get_options() {
	while getopts aAeE:hf:t: opts ; do case $opts in
		a) _SOURCE="auto" ;;
		A) [ "$_SOURCE" ]  && get_msg_start "_e1" "usage_1" || _SOURCE="all" ;;
		e) _EXCLUDE="true" ;;
		E) [ "$_EXCLUDE" ] && get_msg_start "_e2" "usage_1" || _EXFILE="$OPTARG" ;;
		f) [ "$_SOURCE" ]  && get_msg_start "_e1" "usage_1" || _SOURCE="$OPTARG" ;;
		h) get_msg_start "none" "usage_0" ;;
		t) _TIMEOUT="$OPTARG" ;;
		*) exit 1 ;;
	esac  ;  done  ;  shift $(( OPTIND - 1 ))

	# This makes it so that _POSPARAMS has one parameter per line
	_POSPARAMS=$(printf '%s\n' "$@" | uniq)

	# Temp files for locking, timeouts, and IP resolution 
	_TMP_LOCK="${QTMP}/qb-startstop_lock"
	_TMP_TIME="${QTMP}/qb-startstop_timeout"
	_TMP_IP="${QTMP}/qb-start_temp_ip"
	
	# _STARTS is used for calculating the TIMEOUT later on. Initialize to zero
	_STARTS=0
}

checks() {
	# Check validity of TIMEOUT
	[ "$_TIMEOUT" ] && ! chk_integer -g 5 -l 600 -q -- "$_TIMEOUT" \
																		&& get_msg_start "_e5" "exit_1"

	# Trap function
	trap "cleanup_trapped" INT HUP TERM QUIT EXIT

	# Ping check if qb-start may continue, get placed in queue, or exit if timeout happens 
	monitor_startstop -p || get_msg_start "_e0" "exit_1"
}

climb_hierarchy() {

	# Prevent infinite loop. Unlikely to be 50 gateways; more likely circular reference.
	[ "$_depth" -gt 50 ] && get_msg_start "_e3" "exit_1"
	_depth=$(( _depth + 1 ))

	_JAIL="$1"
	_gateway=$(get_jail_parameter -deqs GATEWAY "$_JAIL")

	if echo "$_CLIMBED" | grep -Eq "(^|[[:blank:]]+)${_JAIL}([[:blank:]]+|\$)" ; then
		# _jail gateway path was already handled. Skip further checks.
		return 0

	# _jail is an endpoint. Either has no network, or is top of hierarchy.
	elif [ "$_gateway" = "none" ] || [ -z "$_gateway" ] ; then

		# Assemble list of hierarcy tops. Will later begin starts from this list
		_HIERTOP=$(printf "%b" "${_JAIL}\n${_HIERTOP}" | uniq)

		# Include jail on _FULLIST
		echo "$_FULLIST" | grep -Eq "(^|[[:blank:]]+)${_JAIL}([[:blank:]]+|\$)" \
				|| _FULLIST=$(printf "%b" "${_FULLIST}\n${_JAIL}")

		# Add _jail to the list of jails already climbed and checked.
		_CLIMBED=$(printf "%b" "${_JAIL}\n${_CLIMBED}")

		# If _JAIL needs to be started, increment _starts, for timeout calculation
		chk_isrunning "$_JAIL" || _starts=$(( _starts + 1 ))

	# Make sure _jail is included in FULLIST. (some gateways might not have been on JLIST).
	else
		echo "$_FULLIST" | grep -Eq "(^|[[:blank:]]+)${_JAIL}([[:blank:]]+|\$)" \
				|| _FULLIST=$(printf "%b" "${_FULLIST}\n${_JAIL}")

		# Add _jail to the list of jails already climbed and checked.
		_CLIMBED=$(printf "%b" "${_JAIL}\n${_CLIMBED}")

		# If _JAIL needs to be started, increment _starts, for timeout calculation
		chk_isrunning "$_JAIL" || _starts=$(( _starts + 1 ))

		# Will continue recursively until hierarchy top is reached
		climb_hierarchy "$_gateway"
	fi

	# Chose the larger of the two values. This is the number of serial starts for TIMEOUT calc
	[ "$_starts" -gt "$_STARTS" ] && _STARTS="$_starts"
}

determine_ips() {

	# Map IPs in serial, write to TMP
	for _jail in $_FULLIST ; do

		# IP calculation for 0control
		! chk_isrunning "$_jail" \
				&& printf "%b" "$_jail SSH $(discover_open_ipv4 $_jail 0control)\n" >> $_TMP_IP

		# IP calaculation unnecessary for hierchy tops or running jails
		! chk_isrunning "$_jail" \
			&& ! echo "$_HIERTOP" | grep -Eq "^[[:blank:]]*${_jail}[[:blank:]]*\$" \
				&& printf "%b" "$_jail NET $(discover_open_ipv4 $_jail)\n" >> $_TMP_IP
	done
}

begin_waterfall() {

	_JAILS="$1"
	for _JAIL in $_JAILS; do
		# Only continue the waterfall if jail started successfully
		start_jail "$_JAIL" 2>&1 || get_msg_start "_e4" "exit_1"

		# Determine ENDPOINTS and SUBGATEWAYS (reset the values for each waterfall recursion)
		_SUBGATEWAYS='' ; _ENDPOINTS=''
		for _client in $(get_info -e _CLIENTS $_JAIL); do

			# Check that _client is on the FULLIST (save time)
			if echo "$_FULLIST" | grep -Eq "(^|[[:blank:]]+)${_client}([[:blank:]]+|\$)" ; then
				# If the _client has no further clients, it returns 1, and is an ENDPOINT
				get_info _CLIENTS "$_client" \
					&& _SUBGATEWAYS="$_SUBGATEWAYS $_client" \
					|| _ENDPOINTS="$_ENDPOINTS $_client"
			fi
		done

		# Start each endpoint
		for _end in $_ENDPOINTS ; do
			# Maintain a small stagger between parallel starts. Helps prevent conflicts
			sleep .1
			start_jail $_end 2>&1 &
			_SJ_PIDS="$_SJ_PIDS $!"
		done

		# Subgateways need their own waterfall
		[ -n "$_SUBGATEWAYS" ] && begin_waterfall "$_SUBGATEWAYS"
	done

	# Wait for all of the start_jail sent to background to finish
	wait $_SJ_PIDS
	return 0
}

cleanup_trapped() {

	# Immediately kill the monitoring PID, to help prevent any races for cleanup
	ps -p $_MONITOR_PID > /dev/null 2>&1 && kill -9 $_MONITOR_PID

	# Remove PID from the lock file. If it's empty, all tmp files can be removed
	if [ -e "$_TMP_LOCK" ] ; then
		sed -i '' -E "/^$$\$/ d" $_TMP_LOCK
		[ ! -s "$_TMP_LOCK" ] && rm $_TMP_LOCK $_TMP_IP $_TMP_TIME $_TMP_PIDS > /dev/null 2>&1
	fi
}

main() {

	# Returns $_JLIST, from options and positional arguments. Func shared with qb-start.
	compile_jlist

	# Find gateway hierarchy top for each jail. Returns $_HIERTOP and $_FULLIST
	for _jlist in $_JLIST ; do

		# Function is recursive, so _depth tracks # of cycles to prevent infinite loop.
		_depth=0 ; _starts=0
		climb_hierarchy "$_jlist"
	done

	# IP addr are mapped out ahead of time to prevent overlaps during parallel start
	determine_ips

	# Start the hierarchy tops, then their clients, until all of FULLIST is started
	for _jail in $_HIERTOP; do
		# Each hierarchy top is independent of each other, and can be started in parallel.
		begin_waterfall $_jail &
		_WF_PIDS="$_WF_PIDS $!"	
	done

	# STARTS keeps track of the number of hierchy levels. If 0, there was nothing to start
	[ "$_STARTS" = 0 ] && get_msg_start "_m2"

	# User specified timeout, or use 5 seconds for every hierarchy level 
	monitor_startstop "${_TIMEOUT:=$(( _STARTS * 5))}" &
	_MONITOR_PID="$!"

	# Wait for starts to finish. If TIMEOUT, monitor_startstop will kill -15 this script 
	wait $_WF_PIDS
	get_msg_start "_m1"
}


get_global_variables

get_networking_variables

get_options "$@"

checks

main

