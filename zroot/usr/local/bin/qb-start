#!/bin/sh

# Starting jails in parallel comes with race-condition problems.
	# Overlapping starts of a shared gateway can lock the system
	# auto IP assignments will likely overlap unless managed ahead of time
	# Epair race conditions and mishandling between gateway/client
# This script deconflicts these, starting jails in serial when necessary, parallel if possible

. /usr/local/lib/quBSD/quBSD.sh
. /usr/local/lib/quBSD/msg-start.sh

get_options() {
	while getopts aAeE:hf:t: opts ; do case $opts in
		a) _SOURCE="auto" ;;
		A) [ "$_SOURCE" ]  && get_msg_start "_e1" "usage_1" || _SOURCE="all" ;;
		e) _EXCLUDE="true" ;;
		E) [ "$_EXCLUDE" ] && get_msg_start "_e2" "usage_1" || _EXFILE="$OPTARG" ;;
		f) [ "$_SOURCE" ]  && get_msg_start "_e1" "usage_1" || _SOURCE="$OPTARG" ;;
		h) get_msg_start "none" "usage_0" ;;
		t) _TIMEOUT="$OPTARG" ;;
		*) exit 1 ;;
	esac  ;  done  ;  shift $(( OPTIND - 1 ))

	# This makes it so that _POSPARAMS has one parameter per line
	_POSPARAMS=$(printf '%s\n' "$@" | uniq)

	# Temp file for IP tracking
	_TMP_IP="${QTMP}/qb-start_temp_ip"

	# _STARTS is used for calculating the TIMEOUT later on. Initialize to zero
	_STARTS=0
}

checks() {
	# Check validity of TIMEOUT
	[ "$_TIMEOUT" ] && ! chk_integer -g 5 -l 600 -q -- "$_TIMEOUT" \
																		&& get_msg_start "_e5" "exit_1"

	# Absolutely do not run if another instance if qb-start or qb-stop is already running
	monitor_startstop || get_msg_start "_e0" "exit_1"

	# Function above removes the temp_ip tracker
	mktemp "$_TMP_IP" > /dev/null 2>&1
}

climb_hierarchy() {

	# Prevent infinite loop. Unlikely to be 50 gateways; more likely circular reference.
	[ "$_depth" -gt 50 ] && get_msg_start "_e3" "exit_1"
	_depth=$(( _depth + 1 ))

	_JAIL="$1"
	_gateway=$(get_jail_parameter -deqs GATEWAY "$_JAIL")

	if echo "$_CLIMBED" | grep -Eq "(^|[[:blank:]]+)${_JAIL}([[:blank:]]+|\$)" ; then
		# _jail gateway path was already handled. Skip further checks.
		return 0

	# _jail is an endpoint. Either has no network, or is top of hierarchy.
	elif [ "$_gateway" = "none" ] || [ -z "$_gateway" ] ; then

		# Assemble list of hierarcy tops. Will later begin starts from this list
		_HIERTOP=$(printf "%b" "${_JAIL}\n${_HIERTOP}" | uniq)

		# Include jail on _FULLIST
		echo "$_FULLIST" | grep -Eq "(^|[[:blank:]]+)${_JAIL}([[:blank:]]+|\$)" \
				|| _FULLIST=$(printf "%b" "${_FULLIST}\n${_JAIL}")

		# Add _jail to the list of jails already climbed and checked.
		_CLIMBED=$(printf "%b" "${_JAIL}\n${_CLIMBED}")

		# If _JAIL needs to be started, increment _starts, for timeout calculation
		chk_isrunning "$_JAIL" || _starts=$(( _starts + 1 ))

	# Make sure _jail is included in FULLIST. (some gateways might not have been on JLIST).
	else
		echo "$_FULLIST" | grep -Eq "(^|[[:blank:]]+)${_JAIL}([[:blank:]]+|\$)" \
				|| _FULLIST=$(printf "%b" "${_FULLIST}\n${_JAIL}")

		# Add _jail to the list of jails already climbed and checked.
		_CLIMBED=$(printf "%b" "${_JAIL}\n${_CLIMBED}")

		# If _JAIL needs to be started, increment _starts, for timeout calculation
		chk_isrunning "$_JAIL" || _starts=$(( _starts + 1 ))

		# Will continue recursively until hierarchy top is reached
		climb_hierarchy "$_gateway"
	fi

	# Chose the larger of the two values. This is the number of serial starts for TIMEOUT calc
	[ "$_starts" -gt "$_STARTS" ] && _STARTS="$_starts"
}

determine_ips() {

	# Map IPs in serial, write to TMP
	for _jail in $_FULLIST ; do

		# IP calculation for 0control
		! chk_isrunning "$_jail" \
				&& printf "%b" "$_jail SSH $(discover_open_ipv4 $_jail 0control)\n" >> $_TMP_IP

		# IP calaculation unnecessary for hierchy tops or running jails
		! chk_isrunning "$_jail" \
			&& ! echo "$_HIERTOP" | grep -Eq "^[[:blank:]]*${_jail}[[:blank:]]*\$" \
				&& printf "%b" "$_jail NET $(discover_open_ipv4 $_jail)\n" >> $_TMP_IP
	done
}

begin_waterfall() {

	_JAILS="$1"

	for _JAIL in $_JAILS; do

		# Only continue the waterfall if jail started successfully
		start_jail "$_JAIL" 2>&1 || get_msg_start "_e4" "exit_1"

		# Determine ENDPOINTS and SUBGATEWAYS (reset the values for each waterfall recursion)
		_SUBGATEWAYS='' ; _ENDPOINTS=''

		for _client in $(get_info -e _CLIENTS $_JAIL); do

			# Check that _client is on the FULLIST (save time)
			if echo "$_FULLIST" | grep -Eq "(^|[[:blank:]]+)${_client}([[:blank:]]+|\$)" ; then

				# If the _client has no further clients, it returns 1, and is an ENDPOINT
				get_info _CLIENTS "$_client" \
					&& _SUBGATEWAYS="$_SUBGATEWAYS $_client" \
					|| _ENDPOINTS="$_ENDPOINTS $_client"
			fi
		done

		# Start each endpoint
		for _end in $_ENDPOINTS ; do

			# Maintain a small stagger between parallel starts. Helps prevent conflicts
			sleep .2
			start_jail $_end 2>&1 &
		done

		# Subgateways need their own waterfall
		[ -n "$_SUBGATEWAYS" ] && begin_waterfall "$_SUBGATEWAYS"
	done
}

main() {

	# Returns $_JLIST, from options and positional arguments. Func shared with qb-start.
	compile_jlist

	# Find gateway hierarchy top for each jail. Returns $_HIERTOP and $_FULLIST
	for _jlist in $_JLIST ; do

		# Function is recursive, so _depth tracks # of cycles to prevent infinite loop.
		_depth=0 ; _starts=0
		climb_hierarchy "$_jlist"
	done

	# IP addr are mapped out ahead of time to prevent overlaps during parallel start
	determine_ips

	# Start the hierarchy tops, then their clients, until all of FULLIST is started
	for _jail in $_HIERTOP; do
		# Each hierarchy top is independent of each other, and can be started in parallel.
		begin_waterfall $_jail &
	done

	# User specified, OR, 7.5 secs for every hierarchy level. Monitoring loop sleeps 0.5 sec
	: ${_TIMEOUT:=$(( _STARTS * 15 ))}
	monitor_startstop "$_TIMEOUT" || get_msg "_e6" "exit_1"
}


get_global_variables

get_networking_variables

get_options "$@"

checks

main

