#!/bin/sh

. /usr/local/lib/quBSD/quBSD.sh
. /usr/local/lib/quBSD/msg-connect.sh

get_options() {
	while getopts cdhi:l opts ; do
		case $opts in
			c) _CMD="create" ;;
			d) [ -z "$_CMD" ] && _CMD="destroy" || get_msg_qb_connect "_1" "usage_1" ;;
			h) get_msg_qb_connect "none" "usage_0" ;;
			i) IP0="$OPTARG" manualIP="true" ;;
			l) [ -z "$_CMD" ] && _CMD="list" || get_msg_qb_connect "_1" "usage_1" ;;
		esac
	done

	shift $(( OPTIND - 1 ))

	# Define script variables
	JAIL=${JAIL:="$1"}
	TUNNEL="$2"
	MTU=$(sed -nE "s:^mtu[[:blank:]]+::p" $QBCONF)
	ACTION="get_msg_qubsd"
}

checks() {
	# Must specify a _CMD 
	[ -z "$_CMD" ] && get_msg_qb_connect "_0" "usage_1"	

	case "$_CMD" in
		create) 
			# JAIL must be running, but tunnel can be started later 
			check_isrunning_jail "$JAIL" "return 1" || get_msg_qb_connect "_2" "usage_1"
			
			# IP checks
			if [ -n "$IP0" ] ; then
				# Invalid IP must be rejected
				check_isvalid_ipv4 "$IP0" "$ACTION" || exit 1 

				# Just temporary connections. Warn for convention mismatch, but don't exit  
				check_isqubsd_ipv4 "$IP0" "$ACTION" 
			else

				# Assign IP if not specified by user 
				IP0=$(discover_open_ipv4 "$JAIL" "$ACTION") || exit 1 
			fi
			
			# Check the pf status and security levels
		   check_seclvl || get_msg_qb_connect "_4" "exit_1"
		;;
		destroy)
			# JAIL and TUNNEL must be running (helps prevent accidents) 
			check_isrunning_jail "$JAIL" "return 1" || get_msg_qb_connect "_2" "usage_1"
	
			[ -n "$TUNNEL" ] && ! check_isrunning_jail "$TUNNEL" "$ACTION" \
					&& get_msg_qb_connect "_3" "usage_1"
		;;
	esac
}

check_seclvl() {
	# If JAIL has running pf, seclvl=3 could prevent modification 
	jexec -l -U root $JAIL service -e | grep -q "rc.d/pf" \
			&& _seclvl_J=$(jexec -l -U root $JAIL sysctl kern.securelevel \
					| sed "s/kern.securelevel: //")

	# Return 1 to checks() if either seclvl is too high to modify network
	[ "$_seclvl_J" == "3" ] && return 1 

	# If TUNNEL has running pf, seclvl=3 could prevent modification 
	if check_isrunning_jail "$TUNNEL" ; then
		jexec -l -U root $TUNNEL service -e | grep -q "rc.d/pf" \
				&& _seclvl_T=$(jexec -l -U root $TUNNEL sysctl kern.securelevel \
																| sed "s/kern.securelevel: //") 
	else
		# If TUNNEL is off, but has pf_enabled, use jailmap.conf for the warning 
		grep -Eq 'pf_enable=.*YES' ${M_ZUSR}/${TUNNEL}/rw/etc/rc.conf \
				&& _seclvl_T=$(sed -nE "s/^${TUNNEL}[[:blank:]]+seclvl[[:blank:]]+//p" $JMAP)
	fi
	
	# Return 1 if tunnel seclvl is too high. Must use if/then here, for return 0/1 to work  
	if [ "$_seclvl_T" == "3" ] ; then 
		return 1 
	fi
}

get_local_ip() {

	# Finds the CIDR notated IP address of an jails interface; or `none'
	jexec -l -U root $_jail ifconfig -f inet:cidr $_intf inet \
		| grep -Eo "[[:digit:]]+\.[[:digit:]]+\.[[:digit:]]+\.[[:digit:]]+/[[:digit:]]+" \
			|| echo "none"
}

get_bridge_members() {
	# If _intf is a bridge, add the members
	jexec -l -U root $_jail ifconfig $_intf | egrep -o "member: [^[:blank:]]+" \
		| sed -E "s/member/$_jail $_intf member/g" | sed "s/:[[:blank:]]*/:/g"
}

assemble_interface_list() {
	# For each jail that is running 
	for _jail in $(get_onjails) ; do 
	
		# Cycle through every interface on that jail
		for _intf in $(jexec -l -U root $_jail ifconfig -l) ; do	

			# Pair each _jail/_intf , with the associated ip address 
			_ALL_INTF=$(printf "%b" "$_ALL_INTF\n $_jail  $_intf  $(get_local_ip)")

			# If the _intf is a bridge, add its bridge members to the list 
			[ -z "${_intf##bridge*}" ] \
				&& _ALL_INTF=$(printf "%b" "$_ALL_INTF\n$(get_bridge_members)")
				
		done
	done
	
	# Remove loopbacks; and set columns formatting 
	_ALL_INTF=$(echo "$_ALL_INTF" | grep -v "[[:blank:]]lo0[[:blank:]]" | column -t)

	# Clean up and categorize all_interfaces list for later usage
	_jail_intfs=$(echo "$_ALL_INTF" | egrep "^$JAIL ") 
	_jail_eps=$(echo "$_jail_intfs" | awk '{print $2}' | egrep -o "epair[[:digit:]]+")	
	_tunnel_pairs=$(echo "$_ALL_INTF" | egrep -v "^$JAIL" | egrep "$_jail_eps")	
}

configure_epairs() {
	# Start tunnel if it's off
	check_isrunning_jail "$TUNNEL" || start_jail "$TUNNEL" "$ACTION" || exit 1

	# Create the epair and send to jails
	epair=$(ifconfig epair create)
	ifconfig "${epair%?}a" vnet $TUNNEL
	ifconfig "${epair%?}b" vnet $JAIL

	# Apply IP0 to JAIL and TUNNEL
	jexec -l -U root $JAIL ifconfig "${epair%?}b" inet $IP0 mtu $MTU up

	jexec -l -U root $TUNNEL ifconfig "${epair%?}a" \
										inet "${IP0%.*/*}.1/${IP0#*/}" mtu $MTU up
}

configure_network() {
	# Add the IP to the tunnel's pf table
	[ -e "${M_JAILS}/${TUNNEL}/rw/etc/pf.conf" ] \
			&& jexec -l -U root $TUNNEL pfctl -t pass_ips -T add $IP0

	# Add the IP to the jail's pf table
	[ -e "${M_JAILS}/${JAIL}/rw/etc/pf.conf" ] \
			&& jexec -l -U root $JAIL pfctl -t pass_ips -T add $IP0

	# Add default route and a resolv.conf for jail to connect to the internet
	jexec -l -U root $JAIL route add default "${IP0%.*/*}.1"
	cp ${M_ZUSR}/${TUNNEL}/rw/etc/resolv.conf ${M_JAILS}/${JAIL}/rw/etc/
}

destroy_epairs() {
	if [ -z "$TUNNEL" ] ; then
		
		# If no tunnel, destroy all epairs on JAIL
		_destr_epairs=$(jexec -l -U root $JAIL ifconfig -g epair)
	else
		
		# Othewise only remove the epairs common to both JAIL and TUNNEL	
		_destr_epairs=$(echo "$_tunnel_pairs" | egrep "^${TUNNEL}[[:blank:]]+epair" \
														| awk '{print $2}')
	fi

	echo "${_destr_epairs%?}b" | xargs -I@ ifconfig @ -vnet $JAIL
	echo "${_destr_epairs%?}b" | xargs -I@ ifconfig @ destroy 
}

list_output() {

	if [ -n "$JAIL" ] ; then 
		
		# Show the interfaces on JAIL 
		get_msg_qb_connect "_5" 

		# Show all other jails that connect to JAIL
		[ -n "$_jail_eps" ] && get_msg_qb_connect "_6" 
	else
		
		# List all existing connections for all running jails
		get_msg_qb_connect "_7" 
	fi
}

main() {
	case $_CMD in 
		create)
				configure_epairs
				configure_network
		;;
		destroy)
				assemble_interface_list	
				destroy_epairs
		;;
		list)
				assemble_interface_list	
				list_output
		;;
	esac
}

get_global_variables

get_options "$@"

checks

main



