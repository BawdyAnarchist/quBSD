#!/bin/sh

. /usr/local/lib/quBSD/quBSD.sh
. /usr/local/lib/quBSD/msg-autosnap.sh

get_options() {
	while getopts ':dhl:st:' opts ; do case $opts in
		d) 	DESTROY=true ;;
		h) 	get_msg_autosnap "none" "usage_0" ;;
		l) 	LIST=${OPTARG} ;;
		s) 	SNAPSHOT=true ;;
		t) 	TTL="${OPTARG}" ;;
		:) 	LIST="all" ;;
		\?)   get_msg_autosnap "_2" "usage_1"
	esac done  ;  shift $(( OPTIND - 1 ))

	DATE_UNIX=$(date +%s)
}

checks() {
	# Separate integer from the units for checks
	_INT="${TTL%?}"
	_UNITS="${TTL##*[0-9]}"

	# Ensure that <_INT><_UNITS> is an integer and proper time unit
	if [ -n "$TTL" ] ; then
		! chk_integer -q -g 0 -- "$_INT" && get_msg_autosnap "_1" "usage_1"
		! echo "$_UNITS" | grep -Eq "m|H|D|W|Y" && get_msg_autosnap "_1" "usage_1"
	fi
}

calculate_variables() {
	# SNAPNAME format is unique for each timeframe, for clear visual separation
	# Calculates the destroy-date in unix time, to be stored with snapshot

	if [ -n "$TTL" ] ; then
		case $_UNITS in
			m)	SNAPNAME=$(date +%b%d_%H%M)
				_ttl_unix=$(( _INT * 60 ))
				_ddate_unix=$(( _ttl_unix + DATE_UNIX)) ;;

			H)	SNAPNAME=$(date +%b%d_%H_H)
				_ttl_unix=$(( _INT * 3600 ))
				_ddate_unix=$(( _ttl_unix + DATE_UNIX)) ;;

			D)	SNAPNAME=$(date +%b%d_%H_D)
				_ttl_unix=$(( _INT * 3600 * 24 ))
				_ddate_unix=$(( _ttl_unix + DATE_UNIX)) ;;

			W)	SNAPNAME=$(date +%b%d_%H_W)
				_ttl_unix=$(( _INT * 3600 * 24 * 7 ))
				_ddate_unix=$(( _ttl_unix + DATE_UNIX)) ;;

			M)	SNAPNAME=$(date +%b%d_M)
				_ttl_unix=$(( _INT * 3600 * 24 * 31 ))
				_ddate_unix=$(( _ttl_unix + DATE_UNIX)) ;;

			Y)	SNAPNAME=$(date +%Y%b%d_Annual)
				_ttl_unix=$(( _INT * 3600 * 24 * 365 ))
				_ddate_unix=$(( _ttl_unix + DATE_UNIX)) ;;
		esac
	else
		# If user did not input any [-t] TTL, tag the snapshot as manually created.
		SNAPNAME=$(date +%b%d_%H:%M_Indef)
	fi
}

sync_from_qmap() {

	# Get list of all jails with an AUTOSNAP setting in QMAP
	_jlist=$(qb-list -p AUTOSNAP | grep -E "(true|false)" | awk '{print $1}')
	for _jail in $_jlist ; do

		# Pull the value of the AUTOSNAP, and conform datasets to QMAP
		_value=$(sed -En "s/^${_jail}[[:blank:]]+AUTOSNAP[[:blank:]]+//gp" $QMAP)
		case "$(get_jail_parameter -deqs CLASS "$_jail")" in

			app*)  chk_valid_zfs "${U_ZFS}/${_jail}" \
							 && zfs set qubsd:autosnap="$_value" "${U_ZFS}/${_jail}"
			;;
			root*) chk_valid_zfs "${ROOT_ZFS}/${_jail}" \
							 && zfs set qubsd:autosnap="$_value" "${R_ZFS}/${_jail}"
			;;
		esac
	done
}

list_datasets() {

	if [ "$LIST" != "snapshot" ] ; then
		# Get list of datasets tagged for autosnap
		ZLIST=$(zfs list -rH -o name,qubsd:autosnap,qubsd:backup-location \
													| grep -E "[[:blank:]]+true[[:blank:]]")
		# Print with formatted header
		printf "%b" "\nDATASET_NAME QUBSD:AUTOSNAP QUBSD:BACKUP-LOC\n" \
				  		"$ZLIST" "\n" | column -t
		echo ""
	fi

	if [ "$LIST" != "dataset" ] ; then
		# Get list of snapshots created by autosnap
		SNAPLIST=$(zfs list -H -t snapshot -o \
						name,qubsd:time-to-live,qubsd:destroy-date,qubsd:autocreated \
												| grep -E "yes$" | awk '{print $1, $2, $3}')
		# Print with formatted header
		printf "%b" "\nSNAPSHOT_NAME QUBSD:TIME-TO-LIVE QUBSD:DESTROY-DATE\n" \
				  		"$SNAPLIST" "\n" | column -t
		echo ""
	fi
}

new_snapshots() {
	# Datasets tagged with qubsd:autosnap.
	ZLIST=$(zfs list -rH -o name,qubsd:autosnap \
								| grep -E "[[:blank:]]+true\$" | awk '{print $1}')

	for _dataset in $ZLIST ; do
		# Calculate unix-time destroy-dates based on user input time-to-live.
		calculate_variables

		# Snapshot datasets from the auto list
		zfs snapshot "${_dataset}@${SNAPNAME}"
		zfs set qubsd:autocreated=yes "${_dataset}@${SNAPNAME}"
		zfs set qubsd:autosnap="-" "${_dataset}@${SNAPNAME}"

		# Set the time-to-live and destroy-date for new snapshots
		if [ -n "$TTL" ] ; then
			zfs set qubsd:time-to-live="$TTL" "${_dataset}@${SNAPNAME}"
			zfs set qubsd:destroy-date="$_ddate_unix" "${_dataset}@${SNAPNAME}"
		else
			zfs set qubsd:time-to-live="-" "${_dataset}@${SNAPNAME}"
			zfs set qubsd:destroy-date="-" "${_dataset}@${SNAPNAME}"
		fi
	done
}

update_stale_clones() {
	# Assemble list of children datasets and their origin (parent)
	_rclonelist=$(zfs list -Hro name,origin ${R_ZFS} | grep -Ev -- '-$' | awk '{print $1}')
	_uclonelist=$(zfs list -Hro name,origin ${U_ZFS} | grep -Ev -- '-$' | awk '{print $1}')

	# Update stale zroot clones with latest parent snap (zfs lists chronolgically)
	for _clone in $_rclonelist ; do
		if ! chk_isrunning "${_clone##*/}" ; then
			_origin=$(zfs list -Ho origin $_clone)
			_newsnap=$(zfs list -t snapshot -o name ${_origin%%@*} | tail -1)
			zfs destroy $_clone
			zfs clone -o qubsd:autosnap='false' "$_newsnap"  $_clone
		fi
	done

	# Update stale zusr clones. They might needs fstab replacement and home directory change
	for _clone in $_uclonelist ; do
		_origin=$(zfs list -Ho origin $_clone | sed -E "s/${U_ZFS}\///")
		reclone_zusr ${_clone##*/} "${_origin%%@*}"
	done
}

thin_old_snapshots() {
	# Assemble datasets in zroot tagged with ttl
	_snaplist=$(zfs list -Hrt snapshot -o name,qubsd:destroy-date \
											| grep -E "[[:blank:]]+[[:digit:]]+\$" | awk '{print $1}')

	for _snap in $_snaplist ; do
		_snap_dd=$(zfs list -Ho qubsd:destroy-date $_snap)

		# If dataset is still in use; `zfs destroy` without [-rRf], will fail to /dev/null
		[ "$_snap_dd" -lt "$DATE_UNIX" ] && zfs destroy $_snap > /dev/null 2>&1

		# Check dataset exists, last command might've deleted it
		chk_valid_zfs "$_snap" && _snap_used=$(zfs list -Ho used $_snap)

		# Destroy 0B snaps, except the one that was just created, (tagged with $SNAPNAME (date))
		[ "$_snap_used" = "0B" ] && [ -n "${_snap##*"$SNAPNAME"}" ] \
																	&& zfs destroy $_snap > /dev/null 2>&1
	done
}

main() {
	# Sync from QMAP just in case of differences or hand jammed updates
	sync_from_qmap

	# List first
	[ -n "$LIST" ] && list_datasets && exit 0

	# Make new snapshots, then update stale jails/VMs to latest snapshot
	if [ -n "$SNAPSHOT" ] ; then
		new_snapshots
		update_stale_clones
	fi

	# Destroy snaps with a TTL, or null `zfs-diff` to parent
	[ -n "$DESTROY" ] && thin_old_snapshots
}

get_global_variables

get_options "$@"

checks

main
