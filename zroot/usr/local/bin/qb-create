#!/bin/sh

. /usr/local/lib/quBSD/quBSD.sh
. /usr/local/lib/quBSD/msg-create.sh

get_options() {
	while getopts a:A:c:C:eg:Ghi:m:M:n:r:s:S:t:yz:Z o ; do
		case $o in
			a) AUTOSTART="$OPTARG" ;;
			A) AUTOSNAP="$OPTARG" ;;
			c) CLASS="$OPTARG"; chk_valid_class "$CLASS" || get_msg_create "none" "exit_1" ;;
			C) CPUSET="$OPTARG" ;;
			e) get_msg_create "_examples" "exit_0" ;; 
			g) GATEWAY="$OPTARG" ;;
			G) GUIDED="true" ;;
			h) get_msg_create "none" "usage_0" ;; 
			i) IPV4="$OPTARG" ;; 
			m) MAXMEM="$OPTARG" ;;
			M) MTU="$OPTARG" ;;
			n) NO_DESTROY="$OPTARG" ;;
			r) ROOTJAIL="$OPTARG"; chk_valid_rootjail "$ROOTJAIL" || get_msg_create "none" "exit_1" ;;
			s) SECLVL="$OPTARG" ;;
			S) SCHG="$OPTARG" ;;
			t) TEMPLATE="$OPTARG"; chk_valid_jail "$TEMPLATE" || get_msg_create "none" "exit_1" ;;
			y) _ASSM_Y="true" ;;
			z) U_ZOPT="$OPTARG" ;
		         echo "$U_ZOPT" | grep -Eq "^(dupl|none|empty)\$" \
					|| get_msg_create "_e1" "exit_1" ;;
			Z) R_ZOPT="true" ;;
			*) exit 1 ;;
		esac
	done
	
	shift $(( OPTIND - 1 ))

	# Proposed newjail name is avail, and no conflict with existing or partially existing jails
	NEWJAIL="$1"
	chk_avail_jailname "$NEWJAIL" || exit 1 

	# Need to track the resuls of assignements. Use a temp file
	_TMP_WARN="/tmp/qb_create_warn"  ;  _TMP_PARAMS="/tmp/qb_create_params"

	[ -e "$_TMP_WARN" ] && rm "$_TMP_WARN" 
	[ -e "$_TMP_PARAMS" ] && rm "$_TMP_PARAMS"

	mktemp "$_TMP_WARN" > /dev/null
	mktemp "$_TMP_PARAMS" > /dev/null
}

assign_jail_parameters() {

	# Jail defining parameters that must be specified and valid 
	PARAMS="AUTOSNAP AUTOSTART CLASS CPUSET GATEWAY IPV4 MAXMEM MTU NO_DESTROY ROOTJAIL SCHG SECLVL"

	# Assign jail parameters based on 1) command line ; 2) template ; 3) #defaults in jmap
	[ "$TEMPLATE" ] && PULLFROM="$TEMPLATE" || PULLFROM='#default'

	# Cycle through parameters, define anything without a value, and record results to _TMP files. 
	for _P in $PARAMS ; do

		# Convert UPPER to lower because the functions and variable indirection use lower case 
		local _param=$(echo $_P | tr '[:upper:]' '[:lower:]')	

		# Parameter was not assigned at the command line 
		if [ -z $(eval echo "\${$_P}") ] ; then
			
			if ! get_jail_parameter "$_P" "$PULLFROM" >> "$_TMP_WARN" ; then
				# Bad return on any parameter is acceptable, except CLASS and ROOTJAIL 
				[ "$_P" = "CLASS" ]    && get_msg_create "_e2" "exit_1" 
				[ "$_P" = "ROOTJAIL" ] && get_msg_create "_e2" "exit_1" 
			fi

		else
			# Parameter assigned at cl, needs checked. Critical params already checked, so just _WARN
			eval "chk_valid_${_param}" \"\${$_P}\"  >>  "$_TMP_WARN"
		fi 

		# IPv4 validity was checked, but conformance with quBSD conventions was not. 
		[ "$_P" = "IPV4" ] && chk_isqubsd_ipv4 "$IPV4" "$NEWJAIL"  >>  "$_TMP_WARN" 

		# Record the final param value to _TMP_PARAMS
		eval echo "$NEWJAIL  $_P  \${$_P}" >> "$_TMP_PARAMS"
	done
}

assign_datasets() {
	# To prevent ambiguity/conflicts, all combos of [-c <class>], and class of the <template> are
	# considered. Case statement provides clarity, and opportunity to handle special cases. 

	CLASS_TEMP=$(get_jail_parameter -eq CLASS "$TEMPLATE")

	case "${CLASS}_${CLASS_TEMP}" in 

		dispjail_|rootjail_|ephemeral_)
			# Dispjails and rootjails require [-t <template>].
			get_msg_create "_e3" "exit_1"
		;;

      # Assume what the user wants, based on jmap #default.
		appjail_|appjail_rootjail)
			# [-Z] is only for creating rootjails, not appjails from rootjails 
	     	[ "$R_ZOPT" ] && get_msg_create "_e4" "exit_1" 
			TEMPLATE="${ROOTJAIL}-template"
			R_ZPARENT="${JAILS_ZFS}/${ROOTJAIL}"
			U_ZPARENT="${ZUSR_ZFS}/${TEMPLATE}"

			# If $ROOTJAIL-template doesn't exist, just create an empty zusr. Warn.
			! chk_valid_zfs "$U_ZPARENT" && U_ZOPT="empty" && get_msg_create "_w6" >> $_TMP_WARN
		;;

		appjail_appjail|appjail_dispjail)
			# [-Z] is only for creating rootjails
	     	[ "$R_ZOPT" ] && get_msg_create "_e4" "exit_1" 
			R_ZPARENT="${JAILS_ZFS}/${ROOTJAIL}"
			U_ZPARENT="${ZUSR_ZFS}/${TEMPLATE}"  

			# dispjail template might not have zusr (if disp of rootjail). Check U_ZPARENT exists 
			chk_valid_zfs "$U_ZPARENT" || get_msg_create "_e7" "exit_1"
		;;
		
		dispjail_appjail)
			# [-Z] is only for creating rootjails
	     	[ "$R_ZOPT" ] && get_msg_create "_e4" "exit_1" 
			R_ZPARENT="${JAILS_ZFS}/${ROOTJAIL}"
			U_ZPARENT="${ZUSR_ZFS}/${TEMPLATE}"  

			# Dispjails always clone from another jail 
			U_ZOPT="clone"	

			# Is a dispjail. Needs to have the appjail as a <template> in jailmap 
			echo "$NEWJAIL  TEMPLATE  $TEMPLATE" >> "$_TMP_PARAMS"
		;;

		# New rootjail from any other rootjail.
		rootjail_rootjail)
			R_ZPARENT="${JAILS_ZFS}/${TEMPLATE}"
			U_ZOPT="skip"
		;;

		#Can create a dispjail of a rootjail too. 
		dispjail_rootjail)
			R_ZPARENT="${JAILS_ZFS}/${TEMPLATE}"
			U_ZOPT="skip"

			# If the user entered conflicting options, error and exit
			[ "$TEMPLATE" ] && ! [ "$TEMPLATE" = "$ROOTJAIL" ] && get_msg_create "_e10" "exit_1"

			# Add <template> to jailmap parameters if dispjail
			echo "$NEWJAIL  TEMPLATE  $ROOTJAIL" >> "$_TMP_PARAMS"
		;;

		# New rootjail, but checks for [-Z]. Ensures user intends new rootjail from app/disp jail.
		rootjail_appjail|rootjail_dispjail)
			[ "$R_ZOPT" ] || get_msg_create "_e8" "exit_1"
			R_ZPARENT="${JAILS_ZFS}/${TEMPLATE}" 
			U_ZOPT="skip"
		;;

		# Provide a way to simply copy an existing dispjail. This is NOT creating a disp of a disp
		dispjail_dispjail)
			R_ZPARENT="${JAILS_ZFS}/${ROOTJAIL}"

			# Pass the template of the <template> to the copycat new dispjail parameters
			TEMP_TEMP=$(get_jail_parameter -eq TEMPLATE $TEMPLATE)
			echo "$NEWJAIL  TEMPLATE  $TEMP_TEMP" >> "$_TMP_PARAMS"

			# Either assign the valid zusr dataset to clone dispjail, or set it to skip later on.
			if chk_valid_zfs "${ZUSR_ZFS}/${TEMP_TEMP}" ; then
				U_ZPARENT="${ZUSR_ZFS}/${TEMP_TEMP}" 
				U_ZOPT="clone" 
			else 
				U_ZOPT="skip"
			fi
		;;
	
		# Ephemeral will clone both zroot and zusr, and make a special jail and launch sequence	
		ephemeral_*)
			R_ZPARENT="${JAILS_ZFS}/${TEMPLATE}"
			U_ZPARENT="${ZUSR_ZFS}/${TEMPLATE}"
		;;
	esac

	# If U_ZOPT wasn't specified, assign the default value: <dupl> 
	[ "$U_ZPARENT" ] && [ -z "$U_ZOPT" ] && U_ZOPT="dupl"

	# Root dataset was derived from <template>. Check that it exists. 
	chk_valid_zfs "$R_ZPARENT" || get_msg_create "_e9" "exit_1"

	# Temporary snapshots to be used for jail duplication.
	if [ "${CLASS}" = rootjail ] ; then 
		R_SNAP="${R_ZPARENT}@$(date +%s)"
		zfs snapshot "$R_SNAP" > /dev/null 2>&1

		# The new rootjail should reference itself as the rootjail, and not the template	
		sed -i '' -E "s/ROOTJAIL[[:blank:]]+${ROOTJAIL}/ROOTJAIL ${NEWJAIL}/g"  $_TMP_PARAMS

	elif [ "$CLASS" = "appjail" ] && [ "$U_ZOPT" = "dupl" ] ; then
		U_SNAP="${U_ZPARENT}@$(date +%s)"
		zfs snapshot "$U_SNAP" > /dev/null 2>&1
	fi
}

confirm_creation() {

	# Show the final result of jail parameters
	clear && get_msg_create "_w1" "_cont" 

	# Show the disksize that will be occupied by creating the new jail
	if [ "$CLASS" = "rootjail" ] ; then
		get_msg_create "_w2" "_cont"

	elif [ "${CLASS}_${U_ZOPT}" = "appjail_dupl" ] ; then
		get_msg_create "_w3" "_cont"  
	fi

	# Warnings for jail parameters. 
	if [ -s "$_TMP_WARN" ] ; then 
		get_msg_create "_w4" "_cont" 

		# Regularizes a single blank line at the end (instead of none, or multiple blank lines).
		printf '%s\n' "$(cat $_TMP_WARN)" | sed '/./,$!d' ; echo ""
	fi

	# Get final confirmation, unless [-y] was specified
	if ! [ "$_ASSM_Y" ] ; then 
		get_msg_create "_w5" "_cont" 
		get_user_response || exit 0
	fi
}

change_datasets() {        
	# ZROOT changes: Only new rootjails are duplicated. Everything else is cloned from a rootjail.
	if [ "$CLASS" = "rootjail" ] ; then
		echo ''
		zfs send -P "$R_SNAP" | zfs recv -vo qubsd:autosnap="$AUTOSNAP" "${JAILS_ZFS}/${NEWJAIL}"
		
	else
		reclone_zroot "$NEWJAIL" "$ROOTJAIL"	
	fi

	# U_ZOPT should've been define already. Handle zusr dataset 
	case "$U_ZOPT" in
		skip) 
			# Is rootjail or disp of roojail. 
			return 0
		;;

		dupl)
			echo ''
			zfs send -vP "$U_SNAP" | zfs recv -vo qubsd:autosnap="$AUTOSNAP" "${ZUSR_ZFS}/${NEWJAIL}"
		;;

		clone)

			# Renaming of datasets and files is handled internally to the function
			reclone_zusr "$NEWJAIL" "$TEMPLATE" 
			return 0
		;;

		none)
			# Create the empty dataset 
			zfs create -o qubsd:autosnap="$AUTOSNAP" "${ZUSR_ZFS}/${NEWJAIL}"

			# Create the directory mapping of the template
			for _dir in $(find "${M_ZUSR}/${TEMPLATE}" -type d) ; do
			   _newdir=$(echo $_dir | sed -e "s#${M_ZUSR}/${TEMPLATE}#${M_ZUSR}/${NEWJAIL}#")
				mkdir -p "$_newdir" > /dev/null 2>&1
			done
		;;

		empty)
			# Create the empty dataset with autosnap option
			zfs create -o qubsd:autosnap="$AUTOSNAP" "${ZUSR_ZFS}/${NEWJAIL}"
		;;
	esac		

	# Jail types that don't need the edits below, have already exited the function.
	# Make sure flags are down for rw/etc directory 
	chflags -R noschg ${M_ZUSR}/${NEWJAIL}/rw/etc > /dev/null 2>&1

   # Fix fstab 
	if [ -e "${M_ZUSR}/${NEWJAIL}/rw/etc/fstab" ] ; then

		# Replace template with newjail name
		sed -i '' -E "s/${TEMPLATE}/${NEWJAIL}/g" ${M_ZUSR}/${NEWJAIL}/rw/etc/fstab
	else

		# fstab is required for jail to start, even if everything else is empty 
		mkdir -p ${M_ZUSR}/${NEWJAIL}/rw/etc/
		head -1 /etc/fstab > ${M_ZUSR}/${NEWJAIL}/rw/etc/fstab
	fi

	# If a special pw user file was copied over, it needs to be modified. 
	if pw -V ${M_ZUSR}/${NEWJAIL}/rw/etc/ usershow 1001 >> /dev/null 2>&1 ; then 
		[ -e ${M_ZUSR}/${NEWJAIL}/usr/home/${NEWJAIL} ] || mkdir -p ${M_ZUSR}/${NEWJAIL}/usr/home/${NEWJAIL}
		pw -V ${M_ZUSR}/${NEWJAIL}/rw/etc/ usermod 1001 -l $NEWJAIL
		pw -V ${M_ZUSR}/${NEWJAIL}/rw/etc/ groupmod 1001 -l $NEWJAIL
		pw -V ${M_ZUSR}/${NEWJAIL}/rw/etc/ usermod 1001 -d /usr/home/${NEWJAIL}  >> /dev/null 2>&1
	fi
	
	# home directory must be renamed (if it exists)
	mv ${M_ZUSR}/${NEWJAIL}/usr/home/${TEMPLATE} ${M_ZUSR}/${NEWJAIL}/usr/home/${NEWJAIL} > /dev/null 2>&1
}

change_configs() {

	# Add the parameters to jailmap 
	column -t < "$_TMP_PARAMS"  >> $JMAP

	# Make a tmp file for /etc/jail.conf edits 
	_TMP_JCONF="/tmp/qb_create_jconf"
	mktemp $_TMP_JCONF > /dev/null

	# Modify /etc/jail.conf
	sed -nE "/^${TEMPLATE}[[:blank:]]*\{/,/\}/p" $JCONF >> $_TMP_JCONF 
	sed -i '' -E "s/${TEMPLATE}/${NEWJAIL}/" $_TMP_JCONF 

	if [ "$CLASS" = "rootjail" ] ; then
		sed -i '' -e "/# Rootjails/r $_TMP_JCONF" $JCONF

	elif [ -z "${NEWJAIL##net-*}" ] ; then
		sed -i '' -e "/# Net Jails/r $_TMP_JCONF" $JCONF

	elif [ "$CLASS" = "dispjail" ] ; then
		sed -i '' -e "/# Disp Jails/r $_TMP_JCONF" $JCONF

	else
		sed -i '' -e "/# Production Jails/r $_TMP_JCONF" $JCONF
	fi
}

guided_mode() {

	# OPENING MESSAGE
		clear && get_msg_create "_m0" && read _dummyvar

	# CLASS 
		clear && get_msg_create "_m1"
		get_msg_create "_resp1" "_cont" "CLASS"

	# ROOTJAIL
		clear && get_msg_create "_m2" 
	
		# Messages diverge based on CLASS
		[ "$CLASS" = "rootjail" ] && get_msg_create "_m3" || get_msg_create "_m4" 

		get_msg_create "_resp1" "_cont" "ROOTJAIL"

	# TEMPLATE
		clear

		# Messages diverge based on CLASS 
		case $CLASS in 
			rootjail) get_msg_create "_m5" ; get_msg_create "_resp2" ;;
			appjail)  get_msg_create "_m6" ; get_msg_create "_resp2" ;;
			dispjail) get_msg_create "_m7" ;;
		esac

		# Complex decision tree unavoidable, due to the potential branches. 
		case ${CLASS}_${_RESPONSE} in 

			# Assign the rootjail TEMPLATE as rootjail, since that's what'd normally happen
			rootjail_1) [ "$CLASS" = "rootjail" ] && TEMPLATE="$ROOTJAIL" && return 0 ;;
			rootjail_2) [ "$CLASS" = "rootjail" ] && TEMPLATE="$ROOTJAIL" ;;
			rootjail_3) get_msg_create "_resp2" ;; 
			
			# Will either use template and return to main program, or stay and get parameters 
			appjail_1)  return 0 ;;
			appjail_2)  : ;;

			# These cases need to get user entered template, show parameters, and confirm again
			appjail_3|dispjail*)  
					get_msg_create "_resp1" "_cont" "TEMPLATE"

					# Give user opportunity to keep checking different template parameters
					while : ; do 
						clear && get_msg_create "_m9"	&& get_msg_create "_resp2" 

						! [ "$_RESPONSE" = "3" ] && break
						get_msg_create "_resp1" "_cont" "TEMPLATE"
					done
				
					# A response of 1, means to use the template for rest of params.	
					[ "$_RESPONSE" = "1" ] && return 0
			;;
		esac

	# REMAINING JAIL PARAMETERS, ONE BY ONE

	# AUTOSTART
		clear && get_msg_create "_m11" && get_msg_create "_resp1" "_cont" "AUTOSTART"

	# AUTOSNAP
		get_msg_create "_m12" && get_msg_create "_resp1" "_cont" "AUTOSNAP"

	# CPUSET	
		get_msg_create "_m13" && get_msg_create "_resp1" "_cont" "CPUSET"
	
	# GATEWAY
		clear && get_msg_create "_m14" && get_msg_create "_resp1" "_cont" "GATEWAY"

	# IPV4
		clear && get_msg_create "_m15" && get_msg_create "_resp1" "_cont" "IPV4"

	# MAXMEM
		clear && get_msg_create "_m16" && get_msg_create "_resp1" "_cont" "MAXMEM"

	# MTU
		get_msg_create "_m17" && get_msg_create "_resp1" "_cont" "MTU"

	# NO_DESTROY
		get_msg_create "_m18" && get_msg_create "_resp1" "_cont" "NO_DESTROY"

	# SECLVL
		get_msg_create "_m19" && get_msg_create "_resp1" "_cont" "SECLVL"

	# SCHG
		clear && get_msg_create "_m20" && get_msg_create "_resp1" "_cont" "SCHG"
}

cleanup_finished() {
	# Once complete, only certain temporary item need removed.  
		
	# Remove the TMP files if they exist (ignore if they dont)
	rm $_TMP_WARN $_TMP_PARAMS $_TMP_JCONF > /dev/null 2>&1 

	# Remove the snapshots if they exist (ignore if they dont)
	[ "$R_SNAP" ] && zfs destroy $R_SNAP > /dev/null 2>&1
	[ "$U_SNAP" ] && zfs destroy $U_SNAP > /dev/null 2>&1

	# Helps to standardize having a newline if program is ctrl-c stopped
	echo ''
	
	eval exit "$_exit"
}

cleanup_trapped() {
	# Can't be leaving partially transferred datasets and pieces of newjail laying around 
	zfs destroy -rRf "${JAILS_ZFS}/${NEWJAIL}" > /dev/null 2>&1
	zfs destroy -rRf "${ZUSR_ZFS}/${NEWJAIL}" > /dev/null 2>&1

   sed -i '' -E "/^${NEWJAIL}[[:blank:]]/d" $JMAP > /dev/null 2>&1
	sed -i '' -E "/^${NEWJAIL}(\{|[[:blank:]])/,/^}/d" $JCONF > /dev/null 2>&1

	# Items above should only be removed if the operation was incomplete
	# Items below should be removed regardless of complete/incomplete
	cleanup_finished
	
	_exit='1'
}

main() {

	trap "cleanup_trapped" INT TERM HUP QUIT 

	[ "$GUIDED" ] && guided_mode

	assign_jail_parameters

	assign_datasets

	confirm_creation	

	change_datasets

	change_configs

	_exit='0' && cleanup_finished
}

get_global_variables

get_options "$@"

main 



