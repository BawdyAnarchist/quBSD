#!/bin/sh

. /usr/local/lib/quBSD/quBSD.sh
. /usr/local/lib/quBSD/msg-stop.sh

get_options() {
	while getopts aAeE:hf:Frt:w opts ; do case $opts in
		a) _SOURCE="auto" ;;
		A) [ "$_SOURCE" ]  && get_msg_stop "_e1" "usage_1" || _SOURCE="all" ;;
		e) _EXCLUDE="true" ;;
		E) [ "$_EXCLUDE" ] && get_msg_stop "_e2" "usage_1" || _EXFILE="${OPTARG}" ;;
		f) [ "$_SOURCE" ]  && get_msg_stop "_e1" "usage_1" || _SOURCE="$OPTARG" ;;
		F) FORCE="true" ;;
		h) get_msg_stop "none" "usage_0" ;;
		r) _RESTART="true" ;;
		t) _TIMEOUT="$OPTARG" ;;
		*) exit 1 ;;
	esac  ;  done  ;  shift $(( OPTIND - 1 ))

	# This makes it so that _POSPARAMS has one parameter per line
	_POSPARAMS=$(printf '%s\n' "$@" | uniq)

	_TMP_LOCK="${QTMP}/qb-startstop_lock"
	_TMP_TIME="${QTMP}/qb-startstop_timeout"

	# _STARTS is used for calculating the TIMEOUT later on. Initialize to zero
	_STARTS=0
}

checks() {
	# Check validity of TIMEOUT
	[ "$_TIMEOUT" ] && ! chk_integer -g 5 -l 600 -q -- "$_TIMEOUT" \
																			&& get_msg_stop "_e5" "exit_1"
	# Set trap to cleanup files on exit
	trap "cleanup_trapped" INT TERM HUP QUIT EXIT

   # Ping check if qb-stop may continue, get placed in queue, or exit if timeout happens 
	monitor_startstop -p || get_msg_stop "_e0" "exit_1"
}

climb_hierarchy() {

	# Prevent infinite loop. Unlikely to be 50 gateways; more likely circular reference.
	[ "$_depth" -gt 50 ] && get_msg_stop "_e3" "exit_1"
	_depth=$(( _depth + 1 ))

	_JAIL="$1"
	_gateway=$(get_jail_parameter -deqz GATEWAY "$_JAIL")

	if echo "$_CLIMBED" | grep -Eq "(^|[[:blank:]]+)${_JAIL}([[:blank:]]+|\$)" ; then
		# _JAIL gateway path was already handled. Skip further checks.
		return 0

	# jail is an endpoint. Either has no network, or is top of hierarchy.
	elif [ "$_gateway" = "none" ] || [ -z "$_gateway" ] ; then

		# Assemble list of hierarchy tops. Will later begin shutdowns from this list
		_HIERTOP=$(printf "%b" "${_JAIL}\n${_HIERTOP}" | uniq)

		# Add _JAIL to the list of jails already climbed and checked.
		_CLIMBED=$(printf "%b" "${_JAIL}\n${_CLIMBED}")

      # If _JAIL is on JLIST, and is running, increment _starts, for timeout calculation
		echo "$_JLIST" | grep -Eq "(^|[[:blank:]]+)${_JAIL}([[:blank:]]+|\$)" \
			&& chk_isrunning "$_JAIL" && _starts=$(( _starts + 1 ))

	# jail has a gateway, which (might) be preferenced for shutdown ahead of it
	else
		# Add _JAIL to the list of jails already climbed and checked.
		_CLIMBED=$(printf "%b" "${_JAIL}\n${_CLIMBED}")

      # If _JAIL is on JLIST, and is running, increment _starts, for timeout calculation
		echo "$_JLIST" | grep -Eq "(^|[[:blank:]]+)${_JAIL}([[:blank:]]+|\$)" \
			&& chk_isrunning "$_JAIL" && _starts=$(( _starts + 1 ))

		# Will continue recursively until hierarchy top is reached
		climb_hierarchy "$_gateway"
	fi

	# Chose the larger of the two values. This is the number of serial starts for TIMEOUT calc
	[ "$_starts" -gt "$_STARTS" ] && _STARTS="$_starts"
}

begin_waterfall() {
	# We start from the top level gateway(s) that were "climbed", and shut them down first
	# This prevents separate paths trying to shut down the same jail, and probs with epairs
	# ENDPOINTS have no clients, and can be stopped in parallel (in the background).
	# SUBGATEWAYS have clients, and need to be stopped serially, and recursed.
	# Note that this script would not support multi-pathed gateway/client relationships
	_JAILS="$1"

	for _JAIL in $_JAILS; do

		# Serial stop for gateways. Exception: VMs can stop in background (no VIF race conds)
		echo "$_JLIST" | grep -Eq "(^|[[:blank:]]+)${_JAIL}([[:blank:]]+|\$)" \
			&& eval stop_jail "$_JAIL"

		# Determine ENDPOINTS and SUBGATEWAYS (reset the values for each waterfall recursion)
		_SUBGATEWAYS='' ; _ENDPOINTS=''

		for _client in $(get_info -e _CLIENTS $_JAIL); do

			# If the _client has no further clients, it returns 1, and is an ENDPOINT
			get_info _CLIENTS "$_client" \
				&& _SUBGATEWAYS="$_SUBGATEWAYS $_client" \
				|| _ENDPOINTS="$_ENDPOINTS $_client"
		done

		# Stop each endpoint
		for _end in $_ENDPOINTS ; do

			# Maintain a small stagger between parallel stops. Helps prevent conflicts
			sleep .1

			# If the endpoint is on JLIST, stop it in the background
			echo "$_JLIST" | grep -Eq "(^|[[:blank:]]+)${_end}([[:blank:]]+|\$)" \
				&& stop_jail "$_end" &
				_PIDS="$_PIDS $!"
		done

		# Subgateways need their own recursive waterfall
		[ -n "$_SUBGATEWAYS" ] && begin_waterfall "$_SUBGATEWAYS"
	done
}

force_stop_jlist() {

	# _ASSM_Y is only passed via env variable in monitor_startstop. Should not be user option
	if [ -z "$_ASSM_Y" ] ; then
		get_msg_stop "_m1" "_cont"
		get_user_response || exit 0
	fi

	for _jail in $_JLIST ; do
		stop_jail -f "$_jail"
	done

	exit 0
}

cleanup_trapped() {

	# Immediately kill the monitoring PID, to help prevent any races for cleanup 
	ps -p $_MONITOR_PID > /dev/null 2>&1 && kill -9 $_MONITOR_PID

   # Remove PID from the lock file. If it's empty, all tmp files can be removed
	if [ -e "$_TMP_LOCK" ] ; then
		sed -i '' -E "/^$$\$/ d" $_TMP_LOCK
		[ ! -s "$_TMP_LOCK" ] && rm $_TMP_LOCK $_TMP_IP $_TMP_TIME > /dev/null 2>&1
	fi
} 

main() {

	# Returns $_JLIST, from options and positional arguments. Func shared with qb-start.
	compile_jlist

	# If [-F] was passed, force stop each container serially, one at at time
	[ "$FORCE" ] && force_stop_jlist

	# Check saved for later. Might already be in the middle of qb-stop, when -F needs to kill
	checks

	# Find gateway hierarchy top for each jail. Returns $_HIERTOP
	for _jlist in $_JLIST ; do

		# Function is recursive, so _depth tracks # of cycles to prevent infinite loop.
		_depth=0 ; _starts=0
		climb_hierarchy "$_jlist"
	done

	# Stop the hierarchy tops, then their clients, until all of _JLIST is stopped.
	for _JAIL in $_HIERTOP; do

		# Hierarchy tops are independent, can be stopped in parallel.
		begin_waterfall $_JAIL &
		_PIDS="$_PIDS $!"
	done

	# STARTS keeps track of the number of hiearchy leves. If 0, there was nothing to stop
echo S: $_STARTS
	if [ "$_STARTS" -gt 0 ] ; then 
		# User specified timeout, or 5 secs for every hierarchy level
		monitor_startstop "${_TIMEOUT:=$(( _STARTS * 5 ))}" &
		_MONITOR_PID="$!"
	
		# Wait for stops to finish. If TIMEOUT, monitor_startstop will kill -15 this script
		wait $_PIDS && get_msg_stop "_m2"
		[ "$_RESTART" ] && exec qb-start "$_JLIST"
	else
		get_msg_stop "_m3"	
	fi
}

get_global_variables

get_options "$@"

main

