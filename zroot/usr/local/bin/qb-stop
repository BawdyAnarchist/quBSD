#!/bin/sh

. /usr/local/lib/quBSD/quBSD.sh
. /usr/local/lib/quBSD/msg-stop.sh

get_options() {
	while getopts aAeE:hf:r opts ; do
		case $opts in
			a) _SOURCE="auto" ;;
			A) [ "$_SOURCE" ] && get_msg_stop "_e1" "usage_1" || _SOURCE="all" ;;
			e) _EXCLUDE="true" ;;
			E) [ "$_EXCLUDE" ] && get_msg_stop "_e2" "usage_1" || _EXFILE="${OPTARG}" ;;
			h) get_msg_stop "none" "usage_0" ;;
			f) [ "$_SOURCE" ] && get_msg_stop "_e1" "usage_1" || _SOURCE="$OPTARG" ;; 
			r) _RESTART="true" ;;
			*) exit 1 ;;
		esac
	done

	shift $(( OPTIND - 1 ))

	# This makes it so that _POSPARAMS has one parameter per line
	_POSPARAMS=$(printf '%s\n' "$@" | uniq)

   # Absolutely do not run if another instance of qb-start or qb-stop is already running
	monitor_startstop "1" "" || get_msg_stop "_e0" "exit_1" 
}

remove_jails() {
	# To make this func time-efficient, some creative license is required. 
	for _jail in $_JLIST ; do

		# Check if jail has network clients (implies a common epair)
		if get_info _CLIENTS $_jail ; then 

			# Will error if epair -vnet both jails simultaneously. Wait for completion
			stop_jail_in_background "$_jail" > /dev/null 2>&1
		else
			# Stop jail and send process to background (for time-efficiency).
			stop_jail_in_background "$_jail" > /dev/null 2>&1 &
		fi
	done
}

stop_jail_in_background() {
	# Function can sent to background, but keeps qb-stop process alive, for monitoring purposes.

	local _jail="$1"
	stop_jail "$_jail" > /dev/null 2>&1
}

handle_restarts() {

	if [ "$_RESTART" ] ; then
	
		# Give 30 secs for jails to stop, or error. Send empty file (nothing to rm after done).
		monitor_startstop "60" '###_empty' || get_msg "_e3"
	
		# Only qb-start should be used for parallel jail starts. 
		qb-start "$_JLIST" &
		exit 0
	fi	
}

get_global_variables

get_options "$@"

compile_jlist

remove_jails

handle_restarts &

