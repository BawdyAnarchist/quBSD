#!/bin/sh

. /usr/local/lib/quBSD/quBSD.sh
. /usr/local/lib/quBSD/msg-stop.sh

get_options() {
	while getopts aAeE:hf:Fr opts ; do
		case $opts in
			a) _SOURCE="auto" ;;
			A) [ "$_SOURCE" ] && get_msg_stop "_e1" "usage_1" || _SOURCE="all" ;;
			e) _EXCLUDE="true" ;;
			E) [ "$_EXCLUDE" ] && get_msg_stop "_e2" "usage_1" || _EXFILE="${OPTARG}" ;;
			h) get_msg_stop "none" "usage_0" ;;
			f) [ "$_SOURCE" ] && get_msg_stop "_e1" "usage_1" || _SOURCE="$OPTARG" ;; 
			F) _FORCE="$OPTARG" ;;
			r) _RESTART="true" ;;
			*) exit 1 ;;
		esac
	done

	shift $(( OPTIND - 1 ))

	# This makes it so that _POSPARAMS has one parameter per line
	_POSPARAMS=$(printf '%s\n' "$@" | uniq)

   # Absolutely do not run if another instance of qb-start or qb-stop is already running
	monitor_startstop "1" || get_msg_stop "_e0" "exit_1" 
}

climb_hierarchy() {

	# Prevent infinite loop. Unlikely to be 50 gateways; more likely circular reference.
	[ "$_depth" -gt 50 ] && get_msg_stop "_e3" "exit_1"
	_depth=$(( _depth + 1 ))

	_JAIL="$1"
	_gateway=$(get_jail_parameter -deqz GATEWAY "$_JAIL")

	if echo "$_CLIMBED" | grep -Eq "(^|[[:blank:]]+)${_JAIL}([[:blank:]]+|\$)" ; then
		# _JAIL gateway path was already handled. Skip further checks.
		return 0

	# jail is an endpoint. Either has no network, or is top of hierarchy. 
	elif [ "$_gateway" = "none" ] || [ -z "$_gateway" ] ; then 

		# Assemble list of hierarchy tops. Will later begin shutdowns from this list 
		_HIERTOP=$(printf "%b" "${_JAIL}\n${_HIERTOP}" | uniq)
		
		# Add _JAIL to the list of jails already climbed and checked.
		_CLIMBED=$(printf "%b" "${_JAIL}\n${_CLIMBED}") 

	# jail has a gateway, which (might) be preferenced for shutdown ahead of it
	else
		# Add _JAIL to the list of jails already climbed and checked.
		_CLIMBED=$(printf "%b" "${_JAIL}\n${_CLIMBED}") 
	
		# Will continue recursively until hierarchy top is reached	
		climb_hierarchy "$_gateway"
	fi	
}

begin_waterfall() {
	# We start from the top level gateway(s) that were "climbed", and shut them down first
	# This prevents separate paths trying to shut down the same jail, and probs with epairs 
	# ENDPOINTS have no clients, and can be stopped in parallel (in the background). 
	# SUBGATEWAYS have clients, and need to be stopped serially, and recursed.
	# Note that this script would not support multi-pathed gateway/client relationships

	_JAILS="$1"

	for _JAIL in $_JAILS; do

		# VMs can be stopped in background, as there's no epair race conditions. 
		chk_isvm $_JAIL && _bkgnd='&' || _bkgnd=''

		# If JAIL is on JLIST shut it down, and wait for the shutdown.
		echo "$_JLIST" | grep -Eq "(^|[[:blank:]]+)${_JAIL}([[:blank:]]+|\$)" \
			&& eval stop_jail "$_JAIL" $_bkgnd

		# Determine ENDPOINTS and SUBGATEWAYS (reset the values for each waterfall recursion)
		_SUBGATEWAYS='' ; _ENDPOINTS=''

		for _client in $(get_info -e _CLIENTS $_JAIL); do
			
			# If the _client has no further clients, it returns 1, and is an ENDPOINT
			get_info _CLIENTS "$_client" \
				&& _SUBGATEWAYS="$_SUBGATEWAYS $_client" \
				|| _ENDPOINTS="$_ENDPOINTS $_client"
		done

		# Stop each endpoint
		for _end in $_ENDPOINTS ; do

			# Maintain a small stagger between parallel stops. Helps prevent conflicts
			sleep .1

			# If the endpoint is on JLIST, stop it in the background 
			echo "$_JLIST" | grep -Eq "(^|[[:blank:]]+)${_end}([[:blank:]]+|\$)" \
				&& stop_jail "$_end" &
		done

		# Subgateways need their own recursive waterfall
		[ -n "$_SUBGATEWAYS" ] && begin_waterfall "$_SUBGATEWAYS" 
	done
}

handle_restarts() {

	if [ "$_RESTART" ] ; then

		# Alert that waiting for jails to stop
		get_msg_stop "_m1" 	

		# Give 15 secs for jails to stop, or error. Send empty file.
		monitor_startstop "30" || get_msg "_e3"
	
		# Only qb-start should be used for parallel jail starts. 
		qb-start "$_JLIST" &
		exit 0
	fi	
}

main() {

	# Returns $_JLIST, from options and positional arguments. Func shared with qb-start.
	compile_jlist

	# Find gateway hierarchy top for each jail. Returns $_HIERTOP 
	for _jlist in $_JLIST ; do

		# Function is recursive, so _depth tracks # of cycles to prevent infinite loop. 
		_depth=1
		climb_hierarchy "$_jlist"
	done

	# Stop the hierarchy tops, then their clients, until all of _JLIST is stopped.
	for _JAIL in $_HIERTOP; do

		# Hierarchy tops are independent, can be stopped in parallel.
		begin_waterfall $_JAIL &
	done

exit 0
	handle_restarts
}

get_global_variables

get_options "$@"

main

# Give 30 secs for jails to stop, or error. Send empty file.
monitor_startstop "60" || get_msg "_e3"

exit 0
	
