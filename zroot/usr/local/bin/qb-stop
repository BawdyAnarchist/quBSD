#!/bin/sh

. /usr/local/lib/quBSD/quBSD.sh
. /usr/local/lib/quBSD/msg-stop.sh

get_options() {
	while getopts aAeE:hf:rt:w opts ; do
		case $opts in
			a) _SOURCE="auto" ;;
			A) [ "$_SOURCE" ]  && get_msg_stop "_e1" "usage_1" || _SOURCE="all" ;;
			e) _EXCLUDE="true" ;;
			E) [ "$_EXCLUDE" ] && get_msg_stop "_e2" "usage_1" || _EXFILE="${OPTARG}" ;;
			f) [ "$_SOURCE" ]  && get_msg_stop "_e1" "usage_1" || _SOURCE="$OPTARG" ;;
			h) get_msg_stop "none" "usage_0" ;;
			r) _RESTART="true" ;;
			t) _TIMEOUT="$OPTARG" ;;
			w) _WAIT="true" ;;
			*) exit 1 ;;
		esac
	done

	shift $(( OPTIND - 1 ))

	# This makes it so that _POSPARAMS has one parameter per line
	_POSPARAMS=$(printf '%s\n' "$@" | uniq)

	# _STARTS is used for calculating the TIMEOUT later on. Initialize to zero
	_STARTS=0

	# Assign the monitoring a background or not, based on [-w]
	[ "$_WAIT" ] && _bkgnd='' || _bkgnd='&'
}

checks() {

	# Timeout must be an integer less than 300 and greater than 5
	if [ "$_TIMEOUT" ] && echo "$_TIMEOUT" | ! grep -Eq '^[[:digit:]]+$' ; then
		if [ "$_TIMEOUT" -le 600 ] && [ "$_TIMEOUT" -ge 5 ]
		then _TIMEOUT=$(( _TIMEOUT * 2 ))
		else get_msg_start "_e5" "usage_1"
		fi
	fi

   # Absolutely do not run if another instance of qb-start or qb-stop is already running
	monitor_startstop || get_msg_stop "_e0" "exit_1"
}

climb_hierarchy() {

	# Prevent infinite loop. Unlikely to be 50 gateways; more likely circular reference.
	[ "$_depth" -gt 50 ] && get_msg_stop "_e3" "exit_1"
	_depth=$(( _depth + 1 ))

	_JAIL="$1"
	_gateway=$(get_jail_parameter -eqz GATEWAY "$_JAIL")

	if echo "$_CLIMBED" | grep -Eq "(^|[[:blank:]]+)${_JAIL}([[:blank:]]+|\$)" ; then
		# _JAIL gateway path was already handled. Skip further checks.
		return 0

	# jail is an endpoint. Either has no network, or is top of hierarchy.
	elif [ "$_gateway" = "none" ] || [ -z "$_gateway" ] ; then

		# Assemble list of hierarchy tops. Will later begin shutdowns from this list
		_HIERTOP=$(printf "%b" "${_JAIL}\n${_HIERTOP}" | uniq)

		# Add _JAIL to the list of jails already climbed and checked.
		_CLIMBED=$(printf "%b" "${_JAIL}\n${_CLIMBED}")

      # If _JAIL is on JLIST, and is running, increment _starts, for timeout calculation
		echo "$_JLIST" | grep -Eq "(^|[[:blank:]]+)${_JAIL}([[:blank:]]+|\$)" \
			&& chk_isrunning "$_JAIL" && _starts=$(( _starts + 1 ))

	# jail has a gateway, which (might) be preferenced for shutdown ahead of it
	else
		# Add _JAIL to the list of jails already climbed and checked.
		_CLIMBED=$(printf "%b" "${_JAIL}\n${_CLIMBED}")

      # If _JAIL is on JLIST, and is running, increment _starts, for timeout calculation
		echo "$_JLIST" | grep -Eq "(^|[[:blank:]]+)${_JAIL}([[:blank:]]+|\$)" \
			&& chk_isrunning "$_JAIL" && _starts=$(( _starts + 1 ))

		# Will continue recursively until hierarchy top is reached
		climb_hierarchy "$_gateway"
	fi

	# Chose the larger of the two values. This is the number of serial starts for TIMEOUT calc
	[ "$_starts" -gt "$_STARTS" ] && _STARTS="$_starts"
}

begin_waterfall() {
	# We start from the top level gateway(s) that were "climbed", and shut them down first
	# This prevents separate paths trying to shut down the same jail, and probs with epairs
	# ENDPOINTS have no clients, and can be stopped in parallel (in the background).
	# SUBGATEWAYS have clients, and need to be stopped serially, and recursed.
	# Note that this script would not support multi-pathed gateway/client relationships

	_JAILS="$1"

	for _JAIL in $_JAILS; do

		# Serial stop for gateways. Exception: VMs can stop in background (no VIF race conds)
		echo "$_JLIST" | grep -Eq "(^|[[:blank:]]+)${_JAIL}([[:blank:]]+|\$)" \
			&& eval stop_jail "$_JAIL"

		# Determine ENDPOINTS and SUBGATEWAYS (reset the values for each waterfall recursion)
		_SUBGATEWAYS='' ; _ENDPOINTS=''

		for _client in $(get_info -e _CLIENTS $_JAIL); do

			# If the _client has no further clients, it returns 1, and is an ENDPOINT
			get_info _CLIENTS "$_client" \
				&& _SUBGATEWAYS="$_SUBGATEWAYS $_client" \
				|| _ENDPOINTS="$_ENDPOINTS $_client"
		done

		# Stop each endpoint
		for _end in $_ENDPOINTS ; do

			# Maintain a small stagger between parallel stops. Helps prevent conflicts
			sleep .1

			# If the endpoint is on JLIST, stop it in the background
			echo "$_JLIST" | grep -Eq "(^|[[:blank:]]+)${_end}([[:blank:]]+|\$)" \
				&& stop_jail "$_end" &
		done

		# Subgateways need their own recursive waterfall
		[ -n "$_SUBGATEWAYS" ] && begin_waterfall "$_SUBGATEWAYS"
	done
}

monitor_stop() {
	# Separate function is necessary, so that qb-start can be handed off
	monitor_startstop "$_TIMEOUT" || get_msg "_e4" "exit_1"
}

main() {

	# Returns $_JLIST, from options and positional arguments. Func shared with qb-start.
	compile_jlist

	# Find gateway hierarchy top for each jail. Returns $_HIERTOP
	for _jlist in $_JLIST ; do

		# Function is recursive, so _depth tracks # of cycles to prevent infinite loop.
		_depth=0 ; _starts=0
		climb_hierarchy "$_jlist"
	done

	# Stop the hierarchy tops, then their clients, until all of _JLIST is stopped.
	for _JAIL in $_HIERTOP; do

		# Hierarchy tops are independent, can be stopped in parallel.
		begin_waterfall $_JAIL &
	done

	# User specified, OR, 7.5 secs for every hierarchy level. Monitoring loop sleeps 0.5 sec
	: ${_TIMEOUT:=$(( _STARTS * 15 ))}
	eval monitor_stop $_bkgnd

	[ "$_RESTART" ] && exec qb-start "$_JLIST"
}

get_global_variables

get_options "$@"

checks

main

exit 0
