#!/bin/sh

# This script is useful with quick-keys. Creates a popup xterm to receive a command to
# to be run in a jail. However, passing commands to xterm subshell is not versatile 
# (eg - won't store a `read` variable). So first, the xterm popup is launched; then 
# qb-floatcmd is run again with [-x] option, which receives and runs the user command. 

. /usr/local/lib/quBSD/quBSD.sh
. /usr/local/lib/quBSD/msg-floatcmd.sh

get_options(){
	while getopts hru:x opts ; do
		case $opts in
			h) get_msg_qb_floatcmd "none" "usage_0" ;;
			r) _USER="root" ; ROOT="-r" ;;
			u) _USER="$OPTARG" ;;
			x) PASS="true" ;;
		esac
	done

	shift $(( OPTIND - 1 ))
	JAIL="$1"
	_USER="${_USER:=$JAIL}"
	ACTION="${ACTION:=get_msg_qubsd}"
}

main() {
	
	if [ "$PASS" ] ; then
		
		start_jail "$JAIL" "$ACTION" || get_msg_qb_floatcmd "none" "exit_1"

		# Script is now running on the new xterm, and can properly read in a command 
		printf "%b" "Enter Command for $JAIL. Popup will close automatically" \
					   "\n${_USER}@${JAIL} # "
		read _CMD
		
		# nohup is required, or the launched command will die with the xterm shell
		nohup qb-cmd $ROOT $JAIL $_CMD 

	else	

		# First push a xterm subshell, and run this script again with [-x] option
		xterm -e csh -c "i3-msg -q floating enable, move position center; \
						/bin/csh -c 'qb-floatcmd -x $JAIL'"
	fi
}

get_global_variables

get_options "$@"

main


